{
    "docs": [
        {
            "location": "/", 
            "text": "Meet Will\n\n\nWill is the friendliest, easiest-to-teach bot you've ever used.  He works on hipchat, in rooms and 1-1 chats.\n\n\nHe makes teaching your chat bot this simple:\n\n\n@respond_to(\nhi\n)\ndef say_hello(self, message):\n    self.say(\noh, hello!\n)\n\n\n\n\nLots of batteries are included, and you can get your own will up and running in a couple of minutes.  \n\n\nWill started by \nSteven Skoczen\n, and has been \ncontributed to by lots of folks\n.\n\n\nCheck out the quickstart below!\n\n\n\n\n\nQuickstart\n\n\nHere's how to set up your system and get will running.  If you already write python, it'll probably take less than 5 minutes.\n\n\n\n\nInstall prerequisites\n\n\nWill doesn't need much, just python and a place to store things.\n\n\nWill can store stuff in Redis, Couchbase, or local storage.  Our recommended backend is redis, and we'll describe getting it set up below. \nInformation on using Couchbase or local storage is here\n.\n\n\nInstall redis \n 2.4\n\n\nOfficial documentation is at \nredis.io\n.\n\n\nIf you're on Mac OS X, and using \nhomebrew\n, you can simply:\n\n\nbrew install redis\n\n\n\n\nOn a Redhat (RHEL, Centos, Fedora) machine you can:\n\n\nsudo yum install redis\nsudo service redis enable\nsudo service redis start\n\n\n\n\nOn a Debian (Ubuntu, Mint, KNOPPIX) machine to properly install follow the \nRedis Quickstart\n. But you can start more quickly with:\n\n\nsudo apt-get install redis-server\nredis-server\n\n\n\n\nInstall python \n 2.6\n\n\nMost modern operating systems (Mac OS X, Linux, BSDs, etc) ship with python installed, but if you don't have it, all the info is at \npython.org\n.\n\n\nInstall virtualenv\n\n\nVirtualenv is a tool that lets you keep different python projects separate. It is highly recommended for will (and all other python development!)\n\n\nThe python guide has \na great tutorial on virtualenv\n, if you don't already have it running.  I'd recommend installing the excellent \nvirtualenvwrapper\n library it mentions as well.\n\n\nSet up a virtualenv for will\n\n\nIf you are using virtualenv wrapper:\n\n\n$ mkproject my_will\n# ... some output, setting up the virtualenv\n$ workon my_will\n(my_will) $ \n\n\n\n\nYou're now all ready to install will!\n\n\nGet will running locally\n\n\nSetting up the project\n\n\nInstalling will is simple easy.  Ready? Go!\n\n\nFrom your virtualenv and the folder you want to set up your will in,\n\n\n(my_will) $ pip install will\n# ... output from a bunch of pip libraries installing\n\n(my_will) $ generate_will_project\n# ... output from will making your new project\n\n(my_will) $ ./run_will.py\n# .. the magic begins\n\n\n\n\nThat's it!  \n\n\nNote that the first time you run, you'll probably be missing some configuration. That's OK - \nrun_will\n will check your environment, and walk you through getting and setting any necessary config.  We'll go through the nitty-gritty later, but if you have any odd setup problems, look in \nconfig.py\n - that's where all of the non-sensitive data is stored.\n\n\n\nThis is totally normal output.\n\n\nEventually, you'll reach this screen of joy.  Now, it's time to play!\n\n\n\n\nTesting will out\n\n\nOnce your will is up and running, hop into any of your hipchat rooms, and say hello!\n\n\n@will hi\n\n\n\n\n@will help\n\n\n\n\nYou're up and running - now it's time to \nteach your will a few things\n!", 
            "title": "Get Started"
        }, 
        {
            "location": "/#meet-will", 
            "text": "Will is the friendliest, easiest-to-teach bot you've ever used.  He works on hipchat, in rooms and 1-1 chats.  He makes teaching your chat bot this simple:  @respond_to( hi )\ndef say_hello(self, message):\n    self.say( oh, hello! )  Lots of batteries are included, and you can get your own will up and running in a couple of minutes.    Will started by  Steven Skoczen , and has been  contributed to by lots of folks .  Check out the quickstart below!", 
            "title": "Meet Will"
        }, 
        {
            "location": "/#quickstart", 
            "text": "Here's how to set up your system and get will running.  If you already write python, it'll probably take less than 5 minutes.", 
            "title": "Quickstart"
        }, 
        {
            "location": "/#install-prerequisites", 
            "text": "Will doesn't need much, just python and a place to store things.  Will can store stuff in Redis, Couchbase, or local storage.  Our recommended backend is redis, and we'll describe getting it set up below.  Information on using Couchbase or local storage is here .  Install redis   2.4  Official documentation is at  redis.io .  If you're on Mac OS X, and using  homebrew , you can simply:  brew install redis  On a Redhat (RHEL, Centos, Fedora) machine you can:  sudo yum install redis\nsudo service redis enable\nsudo service redis start  On a Debian (Ubuntu, Mint, KNOPPIX) machine to properly install follow the  Redis Quickstart . But you can start more quickly with:  sudo apt-get install redis-server\nredis-server  Install python   2.6  Most modern operating systems (Mac OS X, Linux, BSDs, etc) ship with python installed, but if you don't have it, all the info is at  python.org .  Install virtualenv  Virtualenv is a tool that lets you keep different python projects separate. It is highly recommended for will (and all other python development!)  The python guide has  a great tutorial on virtualenv , if you don't already have it running.  I'd recommend installing the excellent  virtualenvwrapper  library it mentions as well.  Set up a virtualenv for will  If you are using virtualenv wrapper:  $ mkproject my_will\n# ... some output, setting up the virtualenv\n$ workon my_will\n(my_will) $   You're now all ready to install will!", 
            "title": "Install prerequisites"
        }, 
        {
            "location": "/#get-will-running-locally", 
            "text": "Setting up the project  Installing will is simple easy.  Ready? Go!  From your virtualenv and the folder you want to set up your will in,  (my_will) $ pip install will\n# ... output from a bunch of pip libraries installing\n\n(my_will) $ generate_will_project\n# ... output from will making your new project\n\n(my_will) $ ./run_will.py\n# .. the magic begins  That's it!    Note that the first time you run, you'll probably be missing some configuration. That's OK -  run_will  will check your environment, and walk you through getting and setting any necessary config.  We'll go through the nitty-gritty later, but if you have any odd setup problems, look in  config.py  - that's where all of the non-sensitive data is stored.  \nThis is totally normal output.  Eventually, you'll reach this screen of joy.  Now, it's time to play!   Testing will out  Once your will is up and running, hop into any of your hipchat rooms, and say hello!  @will hi   @will help   You're up and running - now it's time to  teach your will a few things !", 
            "title": "Get will running locally"
        }, 
        {
            "location": "/plugins/basics/", 
            "text": "Teach your will awesome stuff\n\n\nYour will is all yours.  He'll come with all the great functions of the will library, but the power to teach him the things that are really useful to you is completely in your hands.\n\n\nWe've designed will to be the friendliest, easiest-to-teach bot anywhere, where even non-coders can hop in and add new functionality in a matter of minutes.  We hope you'll find him as friendly as we do!\n\n\n\n\nPlugin basics\n\n\nPlugins are just normal python files with at least one class that subclasses \nWillPlugin\n, and at least one method that's decorated. They can live anywhere normal python modules live, and will has some niceties to make organizing them simple.\n\n\nBut sometimes, the best way to learn is to dive right in - so let's make one!\n\n\nHello, world\n\n\nLet's start as simple as they come - a plugin for will to say hello.  Since he already comes with \"hello\", and \"hi\", in this example, we'll go with \"bonjour!\"\n\n\nStep 1: Create a bonjour.py\n\n\nThis file can be called anything, but given the functionality, bonjour seems like a fair name.  Create the file in your plugins folder:\n\n\n\n\nStep 2: Add the plugin python code\n\n\nIn the \nbonjour.py\n file, add this:\n\n\nfrom will.plugin import WillPlugin\nfrom will.decorators import respond_to, periodic, hear, randomly, route, rendered_template, require_settings\n\n\nclass BonjourPlugin(WillPlugin):\n\n    @respond_to(\nbonjour\n)\n    def say_bonjour_will(self, message):\n        \nbonjour: I know how to say bonjour! In French!\n\n        self.reply(message, \nbonjour!\n)\n\n\n\n\n\n\nStep 3: Restart your will\n\n\nFinally, \nctrl+c\n then restart your will to load the new plugin, and you should be able to do this:\n\n\n\n\nEasy, right?  Well, now that you've got your feet wet, let's see  \nwhat else will knows how to notice\n.", 
            "title": "The Basics"
        }, 
        {
            "location": "/plugins/basics/#teach-your-will-awesome-stuff", 
            "text": "Your will is all yours.  He'll come with all the great functions of the will library, but the power to teach him the things that are really useful to you is completely in your hands.  We've designed will to be the friendliest, easiest-to-teach bot anywhere, where even non-coders can hop in and add new functionality in a matter of minutes.  We hope you'll find him as friendly as we do!", 
            "title": "Teach your will awesome stuff"
        }, 
        {
            "location": "/plugins/basics/#plugin-basics", 
            "text": "Plugins are just normal python files with at least one class that subclasses  WillPlugin , and at least one method that's decorated. They can live anywhere normal python modules live, and will has some niceties to make organizing them simple.  But sometimes, the best way to learn is to dive right in - so let's make one!", 
            "title": "Plugin basics"
        }, 
        {
            "location": "/plugins/basics/#hello-world", 
            "text": "Let's start as simple as they come - a plugin for will to say hello.  Since he already comes with \"hello\", and \"hi\", in this example, we'll go with \"bonjour!\"  Step 1: Create a bonjour.py  This file can be called anything, but given the functionality, bonjour seems like a fair name.  Create the file in your plugins folder:   Step 2: Add the plugin python code  In the  bonjour.py  file, add this:  from will.plugin import WillPlugin\nfrom will.decorators import respond_to, periodic, hear, randomly, route, rendered_template, require_settings\n\n\nclass BonjourPlugin(WillPlugin):\n\n    @respond_to( bonjour )\n    def say_bonjour_will(self, message):\n         bonjour: I know how to say bonjour! In French! \n        self.reply(message,  bonjour! )  Step 3: Restart your will  Finally,  ctrl+c  then restart your will to load the new plugin, and you should be able to do this:   Easy, right?  Well, now that you've got your feet wet, let's see   what else will knows how to notice .", 
            "title": "Hello, world"
        }, 
        {
            "location": "/plugins/notice/", 
            "text": "What will can notice\n\n\nWill can notice a variety of things, and this list keeps growing.  When you want your will to pay attention to a particular thing, you'll use one of will's decorators - an example of each is below.\n\n\nRespond to direct mentions\n\n\nSimple enough - if you directly @will mention him in a message \nor\n send him a message in a 1-1 channel, he'll see these.  It's exactly what we used in the hello, world example.\n\n\n@respond_to(\nbonjour\n)\ndef say_bonjour_will(self, message):\n    # Awesome stuff\n\n\n\n\nYou can also use named matches in the regex:\n\n\n@respond_to(\naward (?P\nnum_stars\n\\d)+ gold stars? to (?P\nmention_name\n.*)\n)\ndef gold_stars(self, message, num_stars=1, mention_name=None):\n    # Fantastic gold-starness\n\n\n\n\n@respond_to\n takes a number of options:\n\n\n@respond_to(regex, include_me=False, case_sensitive=False, multiline=False, admin_only=False, acl=[])\n\n\n\n\n\n\nregex\n: a regular expression to match.  Any named matches are passed along as keyword arguments.\n\n\ninclude_me\n: whether will should include the things he says as possible matches\n\n\ncase_sensitive\n: should the regex be case sensitive?\n\n\nmultiline\n: should the regex allow multiline matches?\n\n\nadmin_only\n: only runs the command if the sender is specified as an administrator.\n\n\nacl\n: only runs the command if the sender is member of a specific ACL group. Any set is accepted as an argument.\n\n\n\n\n \n\n\nHear in any message\n\n\nSometimes, you want will to take actions when he sees things in everyday conversation, even if it wasn't directly addressed to him.  That's what \n@hear()\n is for.\n\n\n@hear(\n(?:ran into )?a bug\n)\ndef log_all_bugs(self, message):\n    # Awesome stuff\n\n\n\n\n@hear\n takes a the same options as \nrespond_to\n:\n\n\n@hear(regex, include_me=False, case_sensitive=False, multiline=False, admin_only=False, acl=[])\n\n\n\n\n\n\nregex\n: a regular expression to match.  Any named matches are passed along as keyword arguments.\n\n\ninclude_me\n: whether will should include the things he says as possible matches\n\n\ncase_sensitive\n: should the regex be case sensitive?\n\n\nmultiline\n: should the regex allow multiline matches?\n\n\nadmin_only\n: only runs the command if the sender is specified as an administrator.\n\n\nacl\n: only runs the command if the sender is member of a specific ACL group. Any set is accepted as an argument.\n\n\n\n\n \n\n\nTake an action on a schedule\n\n\nIt's one of the best things about robots - they never, ever forget.  Will's no exception.  The \n@periodic\n decorator makes scheduled tasks simple.\n\n\n@periodic(hour='10', minute='0', day_of_week=\nmon-fri\n)\ndef standup(self):\n    self.say(\n@all Standup! %s\n % settings.WILL_HANGOUT_URL)\n\n\n\n\nUnder the hood, \n@periodic\n uses \napscheduler\n to provide its options, so you can use any of the following as keyword arguments:\n\n\n\n\nyear\n: 4-digit year number\n\n\nmonth\n: month number (1-12)\n\n\nday\n: day of the month (1-31)\n\n\nweek\n: ISO week number (1-53)\n\n\nday_of_week\n: number or name of weekday (0-6 or mon,tue,wed,thu,fri,sat,sun)\n\n\nhour\n: hour (0-23)\n\n\nminute\n: minute (0-59)\n\n\nsecond\n: second (0-59)\n\n\n\n\nFor each of those keys, any of the following expressions are valid values:\n\n\n\n\n*\n (any): Fire on every value\n\n\n*/a\n (any): Fire every a values, starting from the minimum\n\n\na-b\n (any): Fire on any value within the a-b range (a must be smaller than b)\n\n\na-b/c\n (any): Fire every c values within the a-b range\n\n\nxth y\n (day): Fire on the x -th occurrence of weekday y within the month\n\n\nlast\n x\n (day): Fire on the last occurrence of weekday x within the month\n\n\nlast\n (day): Fire on the last day within the month\n\n\nx,y,z\n (any): Fire on any matching expression; can combine any number of any of the above expressions\n\n\n\n\nAwesome, right?\n\n\nHandle webhooks and web pages\n\n\nThat's right. Will's also a full-fledged webserver under the hood, thanks to \nbottle\n.  Using \n@route\n, he can handle webhooks, talk to chat, and render full HTML pages.\n\n\n# Simple\n@route(\n/ping\n)\ndef ping(self):\n    return \nPONG\n\n\n# Render a template with jinja\n@route(\n/keep-alive\n)\n@rendered_template(\nkeep_alive.html\n)\ndef keep_alive(self):\n    return {}\n\n# With full control, multiple templates, still connected to chat.\n@route(\n/complex_page/\npage_id:int\n, method=\nPOST\n)\ndef complex_page(self, page_id):\n    # Talk to chat\n    self.say(\nHey, somebody's loading the complex page.\n)\n    # Get JSON post data:\n    post_data = self.request.json\n\n    # Render templates\n    header = rendered_template(\nheader.html\n, post_data)\n    some_other_context = {\npage_id\n: page_id}\n    some_other_context[\nheader\n] = header\n    return rendered_template(\ncomplex_page.html\n, some_other_context)\n\n\n\n\nDo things randomly\n\n\nVariety is the spice of life, and nobody wants a robot without at least a \nlittle\n personality.  So, will's \n@randomly\n decorator allows you to specify actions that happen randomly, within a given window.\n\n\n@randomly(start_hour='10', end_hour='17', day_of_week=\nmon-fri\n, num_times_per_day=1)\ndef walkmaster(self):\n    self.say(\n@all time for a walk!\n)\n\n\n\n\n@randomly\n accepts a few arguments:\n\n\n@randomly(start_hour=0, end_hour=23, day_of_week=\n*\n, num_times_per_day=1):\n\n\n\n\n\n\nstart_hour\n:  When to start the random window.\n\n\nend_hour\n:  When to end the random window.\n\n\nday_of_week\n:  What days of the week is the window available? Parsed with \napscheduler\n.\n\n\nnum_times_per_day\n:  How many times per day within the window, should actions happen?\n\n\n\n\nNow that you've got a handle on the things will can notice, let's take a look at \nthe ways he can respond\n.", 
            "title": "What Will Can Notice"
        }, 
        {
            "location": "/plugins/notice/#what-will-can-notice", 
            "text": "Will can notice a variety of things, and this list keeps growing.  When you want your will to pay attention to a particular thing, you'll use one of will's decorators - an example of each is below.", 
            "title": "What will can notice"
        }, 
        {
            "location": "/plugins/notice/#respond-to-direct-mentions", 
            "text": "Simple enough - if you directly @will mention him in a message  or  send him a message in a 1-1 channel, he'll see these.  It's exactly what we used in the hello, world example.  @respond_to( bonjour )\ndef say_bonjour_will(self, message):\n    # Awesome stuff  You can also use named matches in the regex:  @respond_to( award (?P num_stars \\d)+ gold stars? to (?P mention_name .*) )\ndef gold_stars(self, message, num_stars=1, mention_name=None):\n    # Fantastic gold-starness  @respond_to  takes a number of options:  @respond_to(regex, include_me=False, case_sensitive=False, multiline=False, admin_only=False, acl=[])   regex : a regular expression to match.  Any named matches are passed along as keyword arguments.  include_me : whether will should include the things he says as possible matches  case_sensitive : should the regex be case sensitive?  multiline : should the regex allow multiline matches?  admin_only : only runs the command if the sender is specified as an administrator.  acl : only runs the command if the sender is member of a specific ACL group. Any set is accepted as an argument.", 
            "title": "Respond to direct mentions"
        }, 
        {
            "location": "/plugins/notice/#hear-in-any-message", 
            "text": "Sometimes, you want will to take actions when he sees things in everyday conversation, even if it wasn't directly addressed to him.  That's what  @hear()  is for.  @hear( (?:ran into )?a bug )\ndef log_all_bugs(self, message):\n    # Awesome stuff  @hear  takes a the same options as  respond_to :  @hear(regex, include_me=False, case_sensitive=False, multiline=False, admin_only=False, acl=[])   regex : a regular expression to match.  Any named matches are passed along as keyword arguments.  include_me : whether will should include the things he says as possible matches  case_sensitive : should the regex be case sensitive?  multiline : should the regex allow multiline matches?  admin_only : only runs the command if the sender is specified as an administrator.  acl : only runs the command if the sender is member of a specific ACL group. Any set is accepted as an argument.", 
            "title": "Hear in any message"
        }, 
        {
            "location": "/plugins/notice/#take-an-action-on-a-schedule", 
            "text": "It's one of the best things about robots - they never, ever forget.  Will's no exception.  The  @periodic  decorator makes scheduled tasks simple.  @periodic(hour='10', minute='0', day_of_week= mon-fri )\ndef standup(self):\n    self.say( @all Standup! %s  % settings.WILL_HANGOUT_URL)  Under the hood,  @periodic  uses  apscheduler  to provide its options, so you can use any of the following as keyword arguments:   year : 4-digit year number  month : month number (1-12)  day : day of the month (1-31)  week : ISO week number (1-53)  day_of_week : number or name of weekday (0-6 or mon,tue,wed,thu,fri,sat,sun)  hour : hour (0-23)  minute : minute (0-59)  second : second (0-59)   For each of those keys, any of the following expressions are valid values:   *  (any): Fire on every value  */a  (any): Fire every a values, starting from the minimum  a-b  (any): Fire on any value within the a-b range (a must be smaller than b)  a-b/c  (any): Fire every c values within the a-b range  xth y  (day): Fire on the x -th occurrence of weekday y within the month  last  x  (day): Fire on the last occurrence of weekday x within the month  last  (day): Fire on the last day within the month  x,y,z  (any): Fire on any matching expression; can combine any number of any of the above expressions   Awesome, right?", 
            "title": "Take an action on a schedule"
        }, 
        {
            "location": "/plugins/notice/#handle-webhooks-and-web-pages", 
            "text": "That's right. Will's also a full-fledged webserver under the hood, thanks to  bottle .  Using  @route , he can handle webhooks, talk to chat, and render full HTML pages.  # Simple\n@route( /ping )\ndef ping(self):\n    return  PONG \n\n# Render a template with jinja\n@route( /keep-alive )\n@rendered_template( keep_alive.html )\ndef keep_alive(self):\n    return {}\n\n# With full control, multiple templates, still connected to chat.\n@route( /complex_page/ page_id:int , method= POST )\ndef complex_page(self, page_id):\n    # Talk to chat\n    self.say( Hey, somebody's loading the complex page. )\n    # Get JSON post data:\n    post_data = self.request.json\n\n    # Render templates\n    header = rendered_template( header.html , post_data)\n    some_other_context = { page_id : page_id}\n    some_other_context[ header ] = header\n    return rendered_template( complex_page.html , some_other_context)", 
            "title": "Handle webhooks and web pages"
        }, 
        {
            "location": "/plugins/notice/#do-things-randomly", 
            "text": "Variety is the spice of life, and nobody wants a robot without at least a  little  personality.  So, will's  @randomly  decorator allows you to specify actions that happen randomly, within a given window.  @randomly(start_hour='10', end_hour='17', day_of_week= mon-fri , num_times_per_day=1)\ndef walkmaster(self):\n    self.say( @all time for a walk! )  @randomly  accepts a few arguments:  @randomly(start_hour=0, end_hour=23, day_of_week= * , num_times_per_day=1):   start_hour :  When to start the random window.  end_hour :  When to end the random window.  day_of_week :  What days of the week is the window available? Parsed with  apscheduler .  num_times_per_day :  How many times per day within the window, should actions happen?   Now that you've got a handle on the things will can notice, let's take a look at  the ways he can respond .", 
            "title": "Do things randomly"
        }, 
        {
            "location": "/plugins/reply/", 
            "text": "How will can respond\n\n\nWill can respond in a variety of ways, and since he's pure python, your imagination is the limit.\n\n\nTalk to the room\n\n\nLike any normal person, will can talk to the chat room, or in 1-1 chats.  To talk to the room in your plugins, you'll want to use the \nself.say()\n method.\n\n\n@respond_to(\nbonjour\n)\ndef say_bonjour_will(self, message):\n    # Awesome stuff\n    self.say(\nBonjour!\n, message=message)\n\n\n\n\n\n\nNote that we pass \nmesssage\n along.  This allows will to route his reply to the correct room.  Without it, he'll just speak to the \nDEFAULT_ROOM\n.\n\n\nsay()\n comes with a number of options, including color, html, and ping notify. \n\n\nself.say(content, message=None, room=None, html=False, color=\ngreen\n, notify=False)\n\n\n\n\n\n\ncontent\n: the content you want to send to the room. Any string will do, HTML or plain text.\n\n\nmessage\n: (optional) The incoming message object\n\n\nroom\n: (optional) The room object (from self.available_rooms) to send the message to.\n\n\nhtml\n: if the message is HTML. \nTrue\n or \nFalse\n.\n\n\ncolor\n: (chat room only) the hipchat color to send. \"yellow\", \"red\", \"green\", \"purple\", \"gray\", or \"random\". Default is \"green\". \n\n\nnotify\n: whether the message should trigger a 'ping' notification. \nTrue\n or \nFalse\n.\n\n\n\n\nReply with a mention\n\n\nSometimes you want will to ping you - that's where @name mentions are great.  To do those in will, you'll want to use \nself.reply()\n\n\n@respond_to(\n^hi\n)   # Basic\ndef hi(self, message):\n    self.reply(message, \nhello, %s!\n % message.sender.nick)\n\n\n\n\n\n\nNote the order of arguments is different here, and \nmesssage\n is required. All the options: \n\n\nself.reply(message, content, html=False, color=\ngreen\n, notify=False)\n\n\n\n\n\n\nmessage\n: The incoming message object.  Required\n\n\ncontent\n: the content you want to send to the room. HTML or plain text.\n\n\nhtml\n: if the message is HTML. \nTrue\n or \nFalse\n.\n\n\ncolor\n: (chat room only) the hipchat color to send. \"yellow\", \"red\", \"green\", \"purple\", \"gray\", or \"random\". Default is \"green\".\n\n\nnotify\n: whether the message should trigger a 'ping' notification. \nTrue\n or \nFalse\n.\n\n\n\n\nTalk to the room from a webhook\n\n\nWhen will recieves messages from webhooks and HTTP requests, he's still connected to chat, and you can use \n.say()\n. By default, he'll speak to \nDEFAULT_ROOM\n.\n\n\n@route(\n/ping\n)\ndef ping(self):\n    self.say(\nPONG!\n)\n\n\n\n\nIf you want to talk to a different room, you can pass in the \nroom\n argument with one of the rooms from \nself.available_rooms\n.\n\n\nSend an email\n\n\nWill has one email backend at the moment, via \nmailgun\n.  If you've set \nDEFAULT_FROM_EMAIL\n, \nMAILGUN_API_URL\n, and \nMAILGUN_API_KEY\n, you can use \nself.send_email()\n\n\n@respond_to(\nstatus report\n)\ndef send_status_report(self):\n    self.send_email(email_list=['jill@example.com'], subject=\nHere's the latest report\n, message=rendered_template(\nreport.html\n, {}))\n\n\n\n\nHere's all the options:\n\n\nself.send_email(from_email=None, email_list=[], subject=\n, message=\n)\n\n\n\n\n\n\nfrom_email\n: (Optional) The email address the message should come from. Defaults to \nDEFAULT_FROM_EMAIL\n.\n\n\nemail_list\n: The list of addresses to send to.\n\n\nsubject\n: (Optional) The email subject.\n\n\nmessage\n: (Optional) The email body.\n\n\n\n\nSchedule a reply for the future\n\n\nSometimes, you want will to make plans for the future.  That's where \nself.schedule_say()\n comes in handy.\n\n\n@randomly(start_hour='10', end_hour='17', day_of_week=\nmon-fri\n, num_times_per_day=1)\ndef walkmaster(self):\n    now = datetime.datetime.now()\n    in_5_minutes = now + datetime.timedelta(minutes=5)\n\n    self.say(\n@all Walk happening in 5 minutes!\n)\n    self.schedule_say(\n@all It's walk time!\n, in_5_minutes)\n\n\n\n\nThe options are pretty much the same as \nself.say\n, with the addition of the \nwhen\n parameter.\n\n\nself.schedule_say(content, when, message=None, room=None, html=False, color=\ngreen\n, notify=False)\n\n\n\n\n\n\ncontent\n: the content you want to send to the room. Any string will do, HTML or plain text.\n\n\nwhen\n: when you want the message to be said. Python \ndatetime\n object.\n\n\nmessage\n: (optional) The incoming message object\n\n\nroom\n: (optional) The room object (from self.available_rooms) to send the message to.\n\n\nhtml\n: if the message is HTML. \nTrue\n or \nFalse\n.\n\n\ncolor\n: (chat room only) the hipchat color to send. \"yellow\", \"red\", \"green\", \"purple\", \"gray\", or \"random\". Default is \"green\".\n\n\nnotify\n: whether the message should trigger a 'ping' notification. \nTrue\n or \nFalse\n.\n\n\n\n\nSet the topic\n\n\nSometimes, it's good to give the conversation some direction.  Will can set the topic in hipchat using \nself.set_topic()\n\n\nimport requests\n\n@respond_to(\nnew topic\n)\ndef give_us_somethin_to_talk_about(self, message):\n    r = requests.get(\nhttp://chatoms.com/chatom.json?Normal=1\nFun=2\nPhilosophy=3\nOut+There=4\n)\n    data = r.json()\n    self.set_topic(data[\ntext\n], message=message)\n\n\n\n\nNote: you can't set the topic of a 1-1 chat. Will will complain politely.  All options:\n\n\nself.set_topic(topic, message=None, room=None) \n\n\n\n\n\n\ntopic\n: The string you want to set the topic to\n\n\nmessage\n: (optional) The incoming message object\n\n\nroom\n: (optional) The room object (from self.available_rooms) to send the message to.\n\n\n\n\nDo any python thing\n\n\nWill is Just Python.  Because of that, your imagination is the limit of what he can do to respond to requests.\n\n\nHere's a few things our will does, every day:\n\n\n\n\nSpins up and tears down staging stacks,\n\n\nMonitors uptime on our production sites, and contacts the on-call developer if things go down,\n\n\nKeeps track of code reviews on pending branches,\n\n\nAdd new signups to our CRM,\n\n\nStarts our daily standup video chat,\n\n\nAnd the list goes on.\n\n\n\n\nWill is open-source, and PRs are very welcome.  If someone wants to write \nself.send_sms()\n, or anything else, it's all yours!\n\n\nReady to make some plugins?  Check out \nhow to create and organize plugins\n.", 
            "title": "How Will Can Respond"
        }, 
        {
            "location": "/plugins/reply/#how-will-can-respond", 
            "text": "Will can respond in a variety of ways, and since he's pure python, your imagination is the limit.", 
            "title": "How will can respond"
        }, 
        {
            "location": "/plugins/reply/#talk-to-the-room", 
            "text": "Like any normal person, will can talk to the chat room, or in 1-1 chats.  To talk to the room in your plugins, you'll want to use the  self.say()  method.  @respond_to( bonjour )\ndef say_bonjour_will(self, message):\n    # Awesome stuff\n    self.say( Bonjour! , message=message)   Note that we pass  messsage  along.  This allows will to route his reply to the correct room.  Without it, he'll just speak to the  DEFAULT_ROOM .  say()  comes with a number of options, including color, html, and ping notify.   self.say(content, message=None, room=None, html=False, color= green , notify=False)   content : the content you want to send to the room. Any string will do, HTML or plain text.  message : (optional) The incoming message object  room : (optional) The room object (from self.available_rooms) to send the message to.  html : if the message is HTML.  True  or  False .  color : (chat room only) the hipchat color to send. \"yellow\", \"red\", \"green\", \"purple\", \"gray\", or \"random\". Default is \"green\".   notify : whether the message should trigger a 'ping' notification.  True  or  False .", 
            "title": "Talk to the room"
        }, 
        {
            "location": "/plugins/reply/#reply-with-a-mention", 
            "text": "Sometimes you want will to ping you - that's where @name mentions are great.  To do those in will, you'll want to use  self.reply()  @respond_to( ^hi )   # Basic\ndef hi(self, message):\n    self.reply(message,  hello, %s!  % message.sender.nick)   Note the order of arguments is different here, and  messsage  is required. All the options:   self.reply(message, content, html=False, color= green , notify=False)   message : The incoming message object.  Required  content : the content you want to send to the room. HTML or plain text.  html : if the message is HTML.  True  or  False .  color : (chat room only) the hipchat color to send. \"yellow\", \"red\", \"green\", \"purple\", \"gray\", or \"random\". Default is \"green\".  notify : whether the message should trigger a 'ping' notification.  True  or  False .", 
            "title": "Reply with a mention"
        }, 
        {
            "location": "/plugins/reply/#talk-to-the-room-from-a-webhook", 
            "text": "When will recieves messages from webhooks and HTTP requests, he's still connected to chat, and you can use  .say() . By default, he'll speak to  DEFAULT_ROOM .  @route( /ping )\ndef ping(self):\n    self.say( PONG! )  If you want to talk to a different room, you can pass in the  room  argument with one of the rooms from  self.available_rooms .", 
            "title": "Talk to the room from a webhook"
        }, 
        {
            "location": "/plugins/reply/#send-an-email", 
            "text": "Will has one email backend at the moment, via  mailgun .  If you've set  DEFAULT_FROM_EMAIL ,  MAILGUN_API_URL , and  MAILGUN_API_KEY , you can use  self.send_email()  @respond_to( status report )\ndef send_status_report(self):\n    self.send_email(email_list=['jill@example.com'], subject= Here's the latest report , message=rendered_template( report.html , {}))  Here's all the options:  self.send_email(from_email=None, email_list=[], subject= , message= )   from_email : (Optional) The email address the message should come from. Defaults to  DEFAULT_FROM_EMAIL .  email_list : The list of addresses to send to.  subject : (Optional) The email subject.  message : (Optional) The email body.", 
            "title": "Send an email"
        }, 
        {
            "location": "/plugins/reply/#schedule-a-reply-for-the-future", 
            "text": "Sometimes, you want will to make plans for the future.  That's where  self.schedule_say()  comes in handy.  @randomly(start_hour='10', end_hour='17', day_of_week= mon-fri , num_times_per_day=1)\ndef walkmaster(self):\n    now = datetime.datetime.now()\n    in_5_minutes = now + datetime.timedelta(minutes=5)\n\n    self.say( @all Walk happening in 5 minutes! )\n    self.schedule_say( @all It's walk time! , in_5_minutes)  The options are pretty much the same as  self.say , with the addition of the  when  parameter.  self.schedule_say(content, when, message=None, room=None, html=False, color= green , notify=False)   content : the content you want to send to the room. Any string will do, HTML or plain text.  when : when you want the message to be said. Python  datetime  object.  message : (optional) The incoming message object  room : (optional) The room object (from self.available_rooms) to send the message to.  html : if the message is HTML.  True  or  False .  color : (chat room only) the hipchat color to send. \"yellow\", \"red\", \"green\", \"purple\", \"gray\", or \"random\". Default is \"green\".  notify : whether the message should trigger a 'ping' notification.  True  or  False .", 
            "title": "Schedule a reply for the future"
        }, 
        {
            "location": "/plugins/reply/#set-the-topic", 
            "text": "Sometimes, it's good to give the conversation some direction.  Will can set the topic in hipchat using  self.set_topic()  import requests\n\n@respond_to( new topic )\ndef give_us_somethin_to_talk_about(self, message):\n    r = requests.get( http://chatoms.com/chatom.json?Normal=1 Fun=2 Philosophy=3 Out+There=4 )\n    data = r.json()\n    self.set_topic(data[ text ], message=message)  Note: you can't set the topic of a 1-1 chat. Will will complain politely.  All options:  self.set_topic(topic, message=None, room=None)    topic : The string you want to set the topic to  message : (optional) The incoming message object  room : (optional) The room object (from self.available_rooms) to send the message to.", 
            "title": "Set the topic"
        }, 
        {
            "location": "/plugins/reply/#do-any-python-thing", 
            "text": "Will is Just Python.  Because of that, your imagination is the limit of what he can do to respond to requests.  Here's a few things our will does, every day:   Spins up and tears down staging stacks,  Monitors uptime on our production sites, and contacts the on-call developer if things go down,  Keeps track of code reviews on pending branches,  Add new signups to our CRM,  Starts our daily standup video chat,  And the list goes on.   Will is open-source, and PRs are very welcome.  If someone wants to write  self.send_sms() , or anything else, it's all yours!  Ready to make some plugins?  Check out  how to create and organize plugins .", 
            "title": "Do any python thing"
        }, 
        {
            "location": "/plugins/create/", 
            "text": "Creating and Organizing plugins\n\n\nWe've designed will to be able to scale from small, personal installs to big, corporate robots.  Here's the best practices on creating and organizing your plugins.\n\n\nWhere do plugins live?\n\n\nSince plugins are just python files, they can live anywhere on the \nPYTHONPATH\n.  Will will look for plugins anywhere on the system \nPYTHONPATH\n, and automatically adds \nwill/plugins\n and \nyour_will/plugins\n to the path.\n\n\nHow do I specify which plugins to load?\n\n\nThe list of plugins to load lives in \nconfig.py\n, as well as a blacklist of plugins that, even if they're on the path, should be ignored.\n\n\nWhen given a module, will imports it, then \nrecursively loads\n all plugins found within it.\n\n\nBoth \nPLUGINS\n and \nPLUGINS_BLACKLIST\n can contain:\n\n\nBuilt-in will plugins, e.g.:\n\n\n\n\nAll built-in modules: \nwill.plugins\n\n\nBuilt-in modules: \nwill.plugins.module_name\n\n\nSpecific plugins: \nwill.plugins.module_name.plugin\n\n\n\n\nPlugins in your will, e.g.:\n\n\n\n\nAll modules: \nplugins\n\n\nA specific module: \nplugins.module_name\n\n\nSpecific plugins: \nplugins.module_name.plugin\n\n\n\n\nPlugins anywhere else on your PYTHONPATH, e.g.:\n\n\n\n\nAll modules: \nsomeapp\n\n\nA specific module: \nsomeapp.module_name\n\n\nSpecific plugins: \nsomeapp.module_name.plugin\n\n\n\n\nHere's the corresponding section of \nconfig.py\n, by default:\n\n\nPLUGINS = [\n    # Built-ins\n    \nwill.plugins.admin\n,\n    \nwill.plugins.chat_room\n,\n    \nwill.plugins.devops\n,\n    \nwill.plugins.friendly\n,\n    \nwill.plugins.help\n,\n    \nwill.plugins.productivity\n,\n    \nwill.plugins.web\n,\n\n    # All plugins in your project.\n    \nplugins\n,\n]\n\n# Don't load any of the plugins in this list.  Same options as above.\nPLUGIN_BLACKLIST = [\n    # \nwill.plugins.friendly.cookies\n,      # But who would deprive will of cookies??\n]\n\n\n\n\nWhat exactly is a plugin?\n\n\nA plugin is just a python file with at least one class that subclasses \nWillPlugin\n, and at least one method that's decorated with \none of will's listen decorators\n.\n\n\nFor example:\n\n\nping.py\n\n\nfrom will.plugin import WillPlugin\nfrom will.decorators import respond_to, periodic, hear, randomly, route, rendered_template, require_settings\n\n\nclass PingPlugin(WillPlugin):\n\n    @respond_to(\n^ping$\n)\n    def ping(self, message):\n        self.reply(message, \nPONG\n)\n\n\n\n\nWhat's a module?\n\n\nModules are a way to group similar plugins.\n\n\nStructurally, a will module is just a python module: a folder with an \n__init__.py\n.\n\n\n\n\nThat's it.\n\n\nWhat about that awesome help text?\n\n\nGlad you asked.  The help text comes from a special variable, expected to be in \n__init__.py\n: \n\n\n__init__.py\n\n\nMODULE_DESCRIPTION = \nOld-fashioned friendliness\n\n\n\n\n\nWhen help runs, plugins are grouped according to their \nMODULE_DESCRIPTION\n, which means you can have physically distinct modules that share the same help grouping.\n\n\n\n\nEasy, right?  Awesome. Now that you know where to put them, take a look at the \nbuilt-in features on WillPlugin\n.", 
            "title": "Creating and Organizing Plugins"
        }, 
        {
            "location": "/plugins/create/#creating-and-organizing-plugins", 
            "text": "We've designed will to be able to scale from small, personal installs to big, corporate robots.  Here's the best practices on creating and organizing your plugins.", 
            "title": "Creating and Organizing plugins"
        }, 
        {
            "location": "/plugins/create/#where-do-plugins-live", 
            "text": "Since plugins are just python files, they can live anywhere on the  PYTHONPATH .  Will will look for plugins anywhere on the system  PYTHONPATH , and automatically adds  will/plugins  and  your_will/plugins  to the path.", 
            "title": "Where do plugins live?"
        }, 
        {
            "location": "/plugins/create/#how-do-i-specify-which-plugins-to-load", 
            "text": "The list of plugins to load lives in  config.py , as well as a blacklist of plugins that, even if they're on the path, should be ignored.  When given a module, will imports it, then  recursively loads  all plugins found within it.  Both  PLUGINS  and  PLUGINS_BLACKLIST  can contain:  Built-in will plugins, e.g.:   All built-in modules:  will.plugins  Built-in modules:  will.plugins.module_name  Specific plugins:  will.plugins.module_name.plugin   Plugins in your will, e.g.:   All modules:  plugins  A specific module:  plugins.module_name  Specific plugins:  plugins.module_name.plugin   Plugins anywhere else on your PYTHONPATH, e.g.:   All modules:  someapp  A specific module:  someapp.module_name  Specific plugins:  someapp.module_name.plugin   Here's the corresponding section of  config.py , by default:  PLUGINS = [\n    # Built-ins\n     will.plugins.admin ,\n     will.plugins.chat_room ,\n     will.plugins.devops ,\n     will.plugins.friendly ,\n     will.plugins.help ,\n     will.plugins.productivity ,\n     will.plugins.web ,\n\n    # All plugins in your project.\n     plugins ,\n]\n\n# Don't load any of the plugins in this list.  Same options as above.\nPLUGIN_BLACKLIST = [\n    #  will.plugins.friendly.cookies ,      # But who would deprive will of cookies??\n]", 
            "title": "How do I specify which plugins to load?"
        }, 
        {
            "location": "/plugins/create/#what-exactly-is-a-plugin", 
            "text": "A plugin is just a python file with at least one class that subclasses  WillPlugin , and at least one method that's decorated with  one of will's listen decorators .  For example:  ping.py  from will.plugin import WillPlugin\nfrom will.decorators import respond_to, periodic, hear, randomly, route, rendered_template, require_settings\n\n\nclass PingPlugin(WillPlugin):\n\n    @respond_to( ^ping$ )\n    def ping(self, message):\n        self.reply(message,  PONG )", 
            "title": "What exactly is a plugin?"
        }, 
        {
            "location": "/plugins/create/#whats-a-module", 
            "text": "Modules are a way to group similar plugins.  Structurally, a will module is just a python module: a folder with an  __init__.py .   That's it.", 
            "title": "What's a module?"
        }, 
        {
            "location": "/plugins/create/#what-about-that-awesome-help-text", 
            "text": "Glad you asked.  The help text comes from a special variable, expected to be in  __init__.py :   __init__.py  MODULE_DESCRIPTION =  Old-fashioned friendliness   When help runs, plugins are grouped according to their  MODULE_DESCRIPTION , which means you can have physically distinct modules that share the same help grouping.   Easy, right?  Awesome. Now that you know where to put them, take a look at the  built-in features on WillPlugin .", 
            "title": "What about that awesome help text?"
        }, 
        {
            "location": "/plugins/builtins/", 
            "text": "Plugin Builtins\n\n\nWill's \nWillPlugin\n class packs in lots of useful functionality to make writing powerful plugins simple.  Let's go through it.\n\n\nStorage\n\n\nWill can remember almost any python object (using \ndill\n), even across reboots.\n\n\nIt's as simple as:\n\n\nself.save(\nmy_key\n, \nmy_value\n)\nself.load(\nmy_key\n, \ndefault value\n)\n\n\n\n\nYou can also save a value temporarily by setting the number of seconds before it expires:\n\n\nself.save(\nmy_key\n, \nmy_value\n, expire=10)\n\n\n\n\nTemplate rendering\n\n\nWill includes \nJinja\n for powerful awesome template rendering.  To use it, just call \nself.rendered_template()\n\n\nself.rendered_template(template_name, context={})\n\n\n\n\n\n\ntemplate_name\n: path to the template, relative to the \nTEMPLATE_DIRS\n specified in \nconfig.py\n.\n\n\ncontext\n: a dictionary to render the template with.\n\n\n\n\nYou can use \nrendered_template()\n directly in a plugin,\n\n\n@respond_to(\nwhat are the rooms\\?\n)\ndef list_rooms(self, message):\n    \nwhat are the rooms?: List all the rooms I know about.\n\n    context = {\nrooms\n: self.available_rooms.values(),}\n    self.say(rendered_template(\nrooms.html\n, context), message=message, html=True)\n\n\n\n\nOr, you can stack it as a decorator.\n\n\n@route(\n/\n)\n@rendered_template(\nhome.html\n)\ndef homepage_listener(self):\n    return {}\n\n\n\n\nA note on \nTEMPLATE_DIRS\n - Will automatically includes the following:\n\n\n\n\nCore Will's \ntemplates\n directory,\n\n\nYour Will's \ntemplates\n directory,\n\n\nAll \ntemplates\n directories in the root of modules specified in \nsettings.PLUGINS\n.\n\n\n\n\nHelp and documentation\n\n\nJust include a docstring, and your command will be included in @will help:\n\n\nclass BonjourPlugin(WillPlugin):\n\n    @respond_to(\nbonjour\n)\n    def say_bonjour_will(self, message):\n        \nbonjour: I know how to say bonjour! In French!\n\n        self.reply(message, \nbonjour!\n)\n\n\n\n\n\n\nIf you've \norganized your plugins in a module\n, your plugin's help text will be grouped by module.\n\n\n\n\nAccess Control\n\n\nYou can restrict certain actions to particular groups, by using will's access control list (ACL) support.\n\n\nUsage\n\n\nTo use ACL, you simply specify ACL groups and the relevant handles in your \nconfig.py\n, then pass \nacl=[]\n into any relevant \n@respond_to\ns or \n@hear\ns. \n\n\nHere's an example with an ops team, and an admin team:\n\n\n# config.py\n\nACL = {\n    \nops\n: [\nsteven\n, \nlevi\n, \nsusan\n],\n    \nadmins\n: [\nwooh\n],\n}\n\n\n\n\nThen, in your listeners:\n\n\n# Allow the ops and admins groups to stop EC2 instances,\n# but only allow admins to terminate the instances.\n\n@respond_to(\nec2 instance stop (?P\ninstance_id\n.*)\n, acl=[\nops\n, \nadmins\n])\ndef stop_ec2_instance(self, message, instance_id):\n    # do AWS stuff\n\n@respond_to(\nec2 instance terminate (?P\ninstance_id\n.*)\n, acl=[\nadmins\n])\ndef terminate_ec2_instance(self, message, instance_id):\n    # do AWS stuff\n\n\n\n\nComplex ACL behaviors, simple as that.\n\n\nAccess settings and config\n\n\nWill takes care of passing in environment variables and config via the \nsettings\n module.  To use it:\n\n\nconfig.py:\n\n\nHELLO_MESSAGE = \nBonjour from config.py\n\n\n\n\n\nor, on the shell:\n\n\n# note the `WILL_` prefix\nexport WILL_HELLO_MESSSAGE=\nBonjour from the environment\n\n\n\n\n\nthen, in any plugin: \n\n\nfrom will import settings\n\nclass BonjourPlugin(WillPlugin):\n\n    @respond_to(\nbonjour\n)\n    def say_bonjour_will(self, message):\n        self.reply(message, settings.HELLO_MESSAGE)\n\n\n\n\nYou can also mark one or more settings as required for your plugin with the \nrequire_settings\n decorator, and they'll be checked on startup.\n\n\nfrom will import settings\n\nclass BonjourPlugin(WillPlugin):\n\n    @require_settings(\nHELLO_MESSAGE\n, \nANOTHER_SETTING\n)\n    @respond_to(\nbonjour\n)\n    def say_bonjour_will(self, message):\n        self.reply(message, settings.HELLO_MESSAGE)\n\n\n\n\nWhen will starts up, he'll make sure they've been set:\n\n\n\n\nGetting a room's history\n\n\nSometimes you'll want to retrieve a room's history. No problem - get the room's object, and the last 75 messages are sitting on \n.history\n.\n\n\nclass HistoryPlugin(WillPlugin):\n\n    @respond_to(\n^get last message\n)\n    def get_history(self, message):\n        room = self.get_room_from_message(message)\n        self.reply(message, room.history[-1][\nmessage\n])\n\n\n\n\n.history\n is pretty much what's returned from the \nHipChat room history API\n - the lone exception is that the date has been converted to a python datetime.\n\n\n    {\n        u'from':{\n            u'mention_name':u'First Last',\n            u'id':xxxx,\n            u'links':{\n                u'self': u'https://api.hipchat.com/v2/user/xxxx'\n            },\n            u'name':u'First Last'\n        },\n        u'date':datetime.datetime(2015, 1, 26, 15, 26, 52),\n        u'mentions':[\n            {\n                u'mention_name':u'FirstLast',\n                u'id':xyxy,\n                u'links':{\n                    u'self': u'https://api.hipchat.com/v2/user/xyxy'\n                },\n                u'name':u'First Last'\n            }\n        ],\n        u'message':u'Hi there!',\n        u'type':u'message',\n        u'id':u'xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx'\n    }\n\n\n\n\nParse natural time\n\n\nOften, it's useful to be able to talk to will about time in natural language.  To make that easy, will includes the helper functions built on \nparsedatetime\n and \nnatural\n: \nself.parse_natural_time\n and \nself.to_natural_day_and_time\n.\n\n\nparse_natural_time\n\n\nself.parse_natural_time(time_string)\n parses a textual time string, and returns a \ndatetime\n object.\n\n\n@respond_to(\nremind me on (?P\nremind_time\n.*)\n)\ndef remind_me_at(self, message, remind_time=None):\n    parsed_time = self.parse_natural_time(remind_time)\n\n\n\n\n\n\nto_natural_day_and_time\n\n\nself.to_natural_day_and_time(my_datetime)\n converts a python \ndatetime\n into a human-friendly string.\n\n\n@respond_to(\nshow_reminders\n)\ndef remind_me_at(self, message, remind_time=None):\n    reminders = self.load(\nreminders\n)\n    for r in reminders:\n        natural_time = self.to_natural_day_and_time(r)\n        self.say(\nOn %s\n % natural_time)\n\n\n\n\nNow you've got the hang of how to write your own plugins - but before you reinvent the wheel, take a look at \nwhat plugins are included in will\n!", 
            "title": "Plugin Builtins"
        }, 
        {
            "location": "/plugins/builtins/#plugin-builtins", 
            "text": "Will's  WillPlugin  class packs in lots of useful functionality to make writing powerful plugins simple.  Let's go through it.", 
            "title": "Plugin Builtins"
        }, 
        {
            "location": "/plugins/builtins/#storage", 
            "text": "Will can remember almost any python object (using  dill ), even across reboots.  It's as simple as:  self.save( my_key ,  my_value )\nself.load( my_key ,  default value )  You can also save a value temporarily by setting the number of seconds before it expires:  self.save( my_key ,  my_value , expire=10)", 
            "title": "Storage"
        }, 
        {
            "location": "/plugins/builtins/#template-rendering", 
            "text": "Will includes  Jinja  for powerful awesome template rendering.  To use it, just call  self.rendered_template()  self.rendered_template(template_name, context={})   template_name : path to the template, relative to the  TEMPLATE_DIRS  specified in  config.py .  context : a dictionary to render the template with.   You can use  rendered_template()  directly in a plugin,  @respond_to( what are the rooms\\? )\ndef list_rooms(self, message):\n     what are the rooms?: List all the rooms I know about. \n    context = { rooms : self.available_rooms.values(),}\n    self.say(rendered_template( rooms.html , context), message=message, html=True)  Or, you can stack it as a decorator.  @route( / )\n@rendered_template( home.html )\ndef homepage_listener(self):\n    return {}  A note on  TEMPLATE_DIRS  - Will automatically includes the following:   Core Will's  templates  directory,  Your Will's  templates  directory,  All  templates  directories in the root of modules specified in  settings.PLUGINS .", 
            "title": "Template rendering"
        }, 
        {
            "location": "/plugins/builtins/#help-and-documentation", 
            "text": "Just include a docstring, and your command will be included in @will help:  class BonjourPlugin(WillPlugin):\n\n    @respond_to( bonjour )\n    def say_bonjour_will(self, message):\n         bonjour: I know how to say bonjour! In French! \n        self.reply(message,  bonjour! )   If you've  organized your plugins in a module , your plugin's help text will be grouped by module.", 
            "title": "Help and documentation"
        }, 
        {
            "location": "/plugins/builtins/#access-control", 
            "text": "You can restrict certain actions to particular groups, by using will's access control list (ACL) support.  Usage  To use ACL, you simply specify ACL groups and the relevant handles in your  config.py , then pass  acl=[]  into any relevant  @respond_to s or  @hear s.   Here's an example with an ops team, and an admin team:  # config.py\n\nACL = {\n     ops : [ steven ,  levi ,  susan ],\n     admins : [ wooh ],\n}  Then, in your listeners:  # Allow the ops and admins groups to stop EC2 instances,\n# but only allow admins to terminate the instances.\n\n@respond_to( ec2 instance stop (?P instance_id .*) , acl=[ ops ,  admins ])\ndef stop_ec2_instance(self, message, instance_id):\n    # do AWS stuff\n\n@respond_to( ec2 instance terminate (?P instance_id .*) , acl=[ admins ])\ndef terminate_ec2_instance(self, message, instance_id):\n    # do AWS stuff  Complex ACL behaviors, simple as that.", 
            "title": "Access Control"
        }, 
        {
            "location": "/plugins/builtins/#access-settings-and-config", 
            "text": "Will takes care of passing in environment variables and config via the  settings  module.  To use it:  config.py:  HELLO_MESSAGE =  Bonjour from config.py   or, on the shell:  # note the `WILL_` prefix\nexport WILL_HELLO_MESSSAGE= Bonjour from the environment   then, in any plugin:   from will import settings\n\nclass BonjourPlugin(WillPlugin):\n\n    @respond_to( bonjour )\n    def say_bonjour_will(self, message):\n        self.reply(message, settings.HELLO_MESSAGE)  You can also mark one or more settings as required for your plugin with the  require_settings  decorator, and they'll be checked on startup.  from will import settings\n\nclass BonjourPlugin(WillPlugin):\n\n    @require_settings( HELLO_MESSAGE ,  ANOTHER_SETTING )\n    @respond_to( bonjour )\n    def say_bonjour_will(self, message):\n        self.reply(message, settings.HELLO_MESSAGE)  When will starts up, he'll make sure they've been set:", 
            "title": "Access settings and config"
        }, 
        {
            "location": "/plugins/builtins/#getting-a-rooms-history", 
            "text": "Sometimes you'll want to retrieve a room's history. No problem - get the room's object, and the last 75 messages are sitting on  .history .  class HistoryPlugin(WillPlugin):\n\n    @respond_to( ^get last message )\n    def get_history(self, message):\n        room = self.get_room_from_message(message)\n        self.reply(message, room.history[-1][ message ])  .history  is pretty much what's returned from the  HipChat room history API  - the lone exception is that the date has been converted to a python datetime.      {\n        u'from':{\n            u'mention_name':u'First Last',\n            u'id':xxxx,\n            u'links':{\n                u'self': u'https://api.hipchat.com/v2/user/xxxx'\n            },\n            u'name':u'First Last'\n        },\n        u'date':datetime.datetime(2015, 1, 26, 15, 26, 52),\n        u'mentions':[\n            {\n                u'mention_name':u'FirstLast',\n                u'id':xyxy,\n                u'links':{\n                    u'self': u'https://api.hipchat.com/v2/user/xyxy'\n                },\n                u'name':u'First Last'\n            }\n        ],\n        u'message':u'Hi there!',\n        u'type':u'message',\n        u'id':u'xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx'\n    }", 
            "title": "Getting a room's history"
        }, 
        {
            "location": "/plugins/builtins/#parse-natural-time", 
            "text": "Often, it's useful to be able to talk to will about time in natural language.  To make that easy, will includes the helper functions built on  parsedatetime  and  natural :  self.parse_natural_time  and  self.to_natural_day_and_time .  parse_natural_time  self.parse_natural_time(time_string)  parses a textual time string, and returns a  datetime  object.  @respond_to( remind me on (?P remind_time .*) )\ndef remind_me_at(self, message, remind_time=None):\n    parsed_time = self.parse_natural_time(remind_time)   to_natural_day_and_time  self.to_natural_day_and_time(my_datetime)  converts a python  datetime  into a human-friendly string.  @respond_to( show_reminders )\ndef remind_me_at(self, message, remind_time=None):\n    reminders = self.load( reminders )\n    for r in reminders:\n        natural_time = self.to_natural_day_and_time(r)\n        self.say( On %s  % natural_time)  Now you've got the hang of how to write your own plugins - but before you reinvent the wheel, take a look at  what plugins are included in will !", 
            "title": "Parse natural time"
        }, 
        {
            "location": "/plugins/bundled/", 
            "text": "Included Plugins\n\n\nWill comes with batteries included, and already does a number of useful things - more are welcome via PR!  Note that not all of these commands are listed in \n@will help\n - some are rare enough that they didn't make sense to add.\n\n\nHere's what he does out of the box:\n\n\nAdministration\n\n\nKeepalive\n\n\nThis plugin pings will once a minute at \nPUBLIC_URL\n, making sure his processes aren't idled in installations like heroku.\n\n\nPing\n\n\nHe's a robot. He should respond to ping. :)\n\n\n\n\nSay\n\n\nThis provides a web endpoint at \n/say/some-phrase\n that will will speak into \nDEFAULT_ROOM\n.  Helpful for pay-no-attention-to-the-hand-behind-the-curtain demos.\n\n\n\n\nStorage\n\n\nProvides several \nadmin-only\n commands for manipulating will's underlying storage.  These methods are also case-sensitive, because they can do Bad Things.\n\n\n\n\n@will How big is the db?\n: Lists the db size in human-friendly units.\n\n\n@will SERIOUSLY. Clear ____\n: Clears a key from the storage\n\n\n@will SERIOUSLY. REALLY. Clear all keys.\n: Clears \neverything\n from storage.  Will will definitely not work after this without a restart, and will tell you so.\n\n\n@will Show me the storage for ____\n: Shows the raw storage value for a given key.\n\n\n\n\nChat rooms\n\n\nProvides a couple of methods for listing and updating will's internal chat room knowledge, and manipulating the current room.\n\n\n\n\n@will what are the rooms?\n:  List the rooms he knows about, including their hipchat IDs.\n\n\n@will who is in this room?\n: List all the participants of the room he's in, including their name and mention name. \n\n\n@will update the room list\n:  Get a new list of rooms from the chat server.\n\n\n@will new topic ____\n:   Set the room topic.\n\n\n\n\nDevops\n\n\nWill is our devops team at GreenKahuna, and in the long term, we plan to abstract and include our stack deployer as a plugin.  For the moment, he just includes a couple basics:\n\n\nEmergency Contacts\n\n\nSaves a set of emergency contacts for team members, and provides a way for anyone on the team to get them in, well, emergencies.\n\n\n\n\n@will set my contact info to ____\n: Accepts a multi-line string with whatever contact info you want to provide.\n\n\n@will contact info\n: Lists contact info for all the team members who have provided it.\n\n\n\n\nGithub status\n\n\nGithub is a critical piece of infrastructure for most dev shops.  When it's having troubles, it's good to know.  This plugin checks github's \nstatus api\n, and alerts chat with the problem when they go down, and again when they're back up.\n\n\nHeroku status\n\n\nHeroku is also really widely used, and if you use it, when it's having troubles, it's good to know.  This plugin checks heroku's \nstatus api\n, and alerts chat with the problem when they go down, and again they're back up.\n\n\nNote: if you don't use heroku, remember you can always disable this plugin in \nconfig.py\n:\n\n\nPLUGIN_BLACKLIST = [\n    \nwill.plugins.devops.heroku_is_up\n,\n]\n\n\n\n\nPagerDuty integration\n\n\nIn case if you have a PagerDuty account and the PD alerts are integrated with your HipChat server, you probably want this feature. You can acknowledge/resolve incidents using @will and what's more, you can set up a maintenance window as well!\n\n\nIf you've set both \nPAGERDUTY_SUBDOMAIN\n and \nPAGERDUTY_API_KEY\n and enabled the plugin in \nconfig.py\n - since it's disabled by default - the plugin will work for you. Get one full access api key from https://YOURSUBDOMAIN.pagerduty.com/api_keys.\n\n\nThis plugin assumes that your PagerDuty e-mail address and your HipChat e-mail address are the same, this is how will associates your HipChat account with PagerDuty account.\n\n\nAcknowledge\n\n\nYou can acknowledge the ongoing incidents. You can do 3 things:\n\n\n\n\n@will pd ack\n: Acknowledge all open incidents assigned to you\n\n\n@will pd ack!\n: Acknowledge all open incidents\n\n\n@will pd ack [incident number 1] [incident number 2]\n: Acknowledge one or more specific incidents\n\n\n\n\n\n\nResolve\n\n\nYou can resolve the acknowledged incidents. You can do 3 things:\n\n\n\n\n@will pd resolve\n: Resolve all acknowledged incidents assigned to you\n\n\n@will pd resolve!\n: Resolve all acknowledged incidents\n\n\n@will pd resolve [incident number 1] [incident number 2]\n: Resolve one or more specific incidents\n\n\n\n\n\n\nReassign\n\n\nYou can reassign one or more incidents to somebody else. \n\n\n@will pd reassign [incident number 1] [incident number2] [mention name]\n: reassign one or more specific incidents.\n\n\n\n\nSchedule maintenance window\n\n\nYou can schedule a maintenance window for a specific service. The last - hour - parameter is optional. The default value is \n1 hour\n.\n\n\n@will pd maintenance [service name] [hour(s)]h\n: Schedule a new maintenance window for x hours\n\n\n\n\nFriendly\n\n\nWill has personality, and we love that about him.  The friendly module includes some nice, silly, and appreciative aspects to will that really rounds out his personality.\n\n\nGood morning / Good night\n\n\nWill responds to \"good morning\", and \"good night\" appropriately, if he hears it.  If it's Friday, he'll even tell you to have a good weekend!\n\n\nHello\n\n\nSaying hello is important.\n\n\n\n\nThanks\n\n\nA little politeness goes a long way.\n\n\n\n\nCookies\n\n\nWe promised silly.\n\n\n\n\nThat's what she said.\n\n\nBecause seriously, bro. Read some awesome thought-provoking quotes, instead.\n\n\n\n\nLove\n\n\nOne day, you'll find yourself saying this.  The response will make your week.\n\n\n\n\nFun\n\n\nThere are a number of fun-facing plugins.  Check 'em out in the fun module or let them surprise you.\n\n\n\n\nHelp\n\n\nHelp\n\n\nLists all the plugin commands with docstrings, bundled by module.\n\n\n\n\nProgrammer help\n\n\nList all regexes for registered \n@hear\n and \n@respond_to\n decorators.  This is what help used to be, and may be pulled in the near future.\n\n\n\n\nProductivity\n\n\nBitly\n\n\nIf you want to shorten long URL using Bitly API, Will can do that for you in a few seconds:\n\n\n\n\nHangout\n\n\nIf you've set a \nHANGOUT_URL\n, will will toss it in chat for you:\n\n\n\n\nImage me\n\n\nSometimes, a picture is worth a thousand words.\n\n\n\n\nRemind me\n\n\nThis saves our bacon every day. Timeboxes meetings, helps people remember appointments, and enforces self-control.\n\n\n\n\nThen, when it's 3pm, and I still haven't stopped coding to eat:\n\n\n\n\nOr, more practically,\n\n\n\n\nRemind somebody\n\n\nYou can also remind others as well.\n\n\n\n\nWorld time\n\n\nWe're a remote company. Maybe you are too. Or your clients are.  Or the light/dark cycle of the world just fascinates you.  If any of these are you,\n\n\n\n\nGet a free \nWORLD_WEATHER_ONLINE_V2_KEY\n from \nworld weather online\n.\n\n\nGet the time in pretty much any city on earth.  Even our globe-trotting CEO hasn't been able to stump him.\n\n\n\n\n\n\nVersion\n\n\nProvides information about the release version of @will.\n\n\n\n\n@will version\n: Show the current running version.\n\n\n\n\nWeb\n\n\nThis module's all about web-facing content.\n\n\nHome page\n\n\nWill also includes a home page, so you can fire him, up, browse to his URL, and see his smiling face.\n\n\n\n\nYou now know everything about plugins.  Maybe you're wondering about the \nfiner points of config\n?  Or perhaps, you're ready to \ndeploy your will\n?", 
            "title": "Bundled Plugins"
        }, 
        {
            "location": "/plugins/bundled/#included-plugins", 
            "text": "Will comes with batteries included, and already does a number of useful things - more are welcome via PR!  Note that not all of these commands are listed in  @will help  - some are rare enough that they didn't make sense to add.  Here's what he does out of the box:", 
            "title": "Included Plugins"
        }, 
        {
            "location": "/plugins/bundled/#administration", 
            "text": "Keepalive  This plugin pings will once a minute at  PUBLIC_URL , making sure his processes aren't idled in installations like heroku.  Ping  He's a robot. He should respond to ping. :)   Say  This provides a web endpoint at  /say/some-phrase  that will will speak into  DEFAULT_ROOM .  Helpful for pay-no-attention-to-the-hand-behind-the-curtain demos.   Storage  Provides several  admin-only  commands for manipulating will's underlying storage.  These methods are also case-sensitive, because they can do Bad Things.   @will How big is the db? : Lists the db size in human-friendly units.  @will SERIOUSLY. Clear ____ : Clears a key from the storage  @will SERIOUSLY. REALLY. Clear all keys. : Clears  everything  from storage.  Will will definitely not work after this without a restart, and will tell you so.  @will Show me the storage for ____ : Shows the raw storage value for a given key.", 
            "title": "Administration"
        }, 
        {
            "location": "/plugins/bundled/#chat-rooms", 
            "text": "Provides a couple of methods for listing and updating will's internal chat room knowledge, and manipulating the current room.   @will what are the rooms? :  List the rooms he knows about, including their hipchat IDs.  @will who is in this room? : List all the participants of the room he's in, including their name and mention name.   @will update the room list :  Get a new list of rooms from the chat server.  @will new topic ____ :   Set the room topic.", 
            "title": "Chat rooms"
        }, 
        {
            "location": "/plugins/bundled/#devops", 
            "text": "Will is our devops team at GreenKahuna, and in the long term, we plan to abstract and include our stack deployer as a plugin.  For the moment, he just includes a couple basics:  Emergency Contacts  Saves a set of emergency contacts for team members, and provides a way for anyone on the team to get them in, well, emergencies.   @will set my contact info to ____ : Accepts a multi-line string with whatever contact info you want to provide.  @will contact info : Lists contact info for all the team members who have provided it.   Github status  Github is a critical piece of infrastructure for most dev shops.  When it's having troubles, it's good to know.  This plugin checks github's  status api , and alerts chat with the problem when they go down, and again when they're back up.  Heroku status  Heroku is also really widely used, and if you use it, when it's having troubles, it's good to know.  This plugin checks heroku's  status api , and alerts chat with the problem when they go down, and again they're back up.  Note: if you don't use heroku, remember you can always disable this plugin in  config.py :  PLUGIN_BLACKLIST = [\n     will.plugins.devops.heroku_is_up ,\n]  PagerDuty integration  In case if you have a PagerDuty account and the PD alerts are integrated with your HipChat server, you probably want this feature. You can acknowledge/resolve incidents using @will and what's more, you can set up a maintenance window as well!  If you've set both  PAGERDUTY_SUBDOMAIN  and  PAGERDUTY_API_KEY  and enabled the plugin in  config.py  - since it's disabled by default - the plugin will work for you. Get one full access api key from https://YOURSUBDOMAIN.pagerduty.com/api_keys.  This plugin assumes that your PagerDuty e-mail address and your HipChat e-mail address are the same, this is how will associates your HipChat account with PagerDuty account.  Acknowledge  You can acknowledge the ongoing incidents. You can do 3 things:   @will pd ack : Acknowledge all open incidents assigned to you  @will pd ack! : Acknowledge all open incidents  @will pd ack [incident number 1] [incident number 2] : Acknowledge one or more specific incidents    Resolve  You can resolve the acknowledged incidents. You can do 3 things:   @will pd resolve : Resolve all acknowledged incidents assigned to you  @will pd resolve! : Resolve all acknowledged incidents  @will pd resolve [incident number 1] [incident number 2] : Resolve one or more specific incidents    Reassign  You can reassign one or more incidents to somebody else.   @will pd reassign [incident number 1] [incident number2] [mention name] : reassign one or more specific incidents.   Schedule maintenance window  You can schedule a maintenance window for a specific service. The last - hour - parameter is optional. The default value is  1 hour .  @will pd maintenance [service name] [hour(s)]h : Schedule a new maintenance window for x hours", 
            "title": "Devops"
        }, 
        {
            "location": "/plugins/bundled/#friendly", 
            "text": "Will has personality, and we love that about him.  The friendly module includes some nice, silly, and appreciative aspects to will that really rounds out his personality.  Good morning / Good night  Will responds to \"good morning\", and \"good night\" appropriately, if he hears it.  If it's Friday, he'll even tell you to have a good weekend!  Hello  Saying hello is important.   Thanks  A little politeness goes a long way.   Cookies  We promised silly.   That's what she said.  Because seriously, bro. Read some awesome thought-provoking quotes, instead.   Love  One day, you'll find yourself saying this.  The response will make your week.", 
            "title": "Friendly"
        }, 
        {
            "location": "/plugins/bundled/#fun", 
            "text": "There are a number of fun-facing plugins.  Check 'em out in the fun module or let them surprise you.", 
            "title": "Fun"
        }, 
        {
            "location": "/plugins/bundled/#help", 
            "text": "Help  Lists all the plugin commands with docstrings, bundled by module.   Programmer help  List all regexes for registered  @hear  and  @respond_to  decorators.  This is what help used to be, and may be pulled in the near future.", 
            "title": "Help"
        }, 
        {
            "location": "/plugins/bundled/#productivity", 
            "text": "Bitly  If you want to shorten long URL using Bitly API, Will can do that for you in a few seconds:   Hangout  If you've set a  HANGOUT_URL , will will toss it in chat for you:   Image me  Sometimes, a picture is worth a thousand words.   Remind me  This saves our bacon every day. Timeboxes meetings, helps people remember appointments, and enforces self-control.   Then, when it's 3pm, and I still haven't stopped coding to eat:   Or, more practically,   Remind somebody  You can also remind others as well.   World time  We're a remote company. Maybe you are too. Or your clients are.  Or the light/dark cycle of the world just fascinates you.  If any of these are you,   Get a free  WORLD_WEATHER_ONLINE_V2_KEY  from  world weather online .  Get the time in pretty much any city on earth.  Even our globe-trotting CEO hasn't been able to stump him.", 
            "title": "Productivity"
        }, 
        {
            "location": "/plugins/bundled/#version", 
            "text": "Provides information about the release version of @will.   @will version : Show the current running version.", 
            "title": "Version"
        }, 
        {
            "location": "/plugins/bundled/#web", 
            "text": "This module's all about web-facing content.  Home page  Will also includes a home page, so you can fire him, up, browse to his URL, and see his smiling face.   You now know everything about plugins.  Maybe you're wondering about the  finer points of config ?  Or perhaps, you're ready to  deploy your will ?", 
            "title": "Web"
        }, 
        {
            "location": "/config/", 
            "text": "Configuring Will\n\n\nMost of will's configuration is done interactively, using \nrun_will.py\n, or specifying via the plugins.  There are, however a few built-in settings and config worth covering.  We'll aim to address all of them here.\n\n\nEnvironment variables\n\n\nAll environment variables prefixed with \nWILL_\n are imported into will's \nsettings\n modules.\n\n\nIn best practices, you should keep all of the following in environment variables:\n\n\n\n\nWILL_USERNAME\n\n\nWILL_PASSWORD\n\n\nWILL_REDIS_URL\n\n\nWILL_V2_TOKEN\n\n\nWILL_V1_TOKEN\n\n\nAny other tokens, keys, passwords, or sensitive URLS.\n\n\n\n\nWe've made it easy.  No excuses. :)\n\n\nconfig.py\n\n\nConfig.py is where all of your non-sensitive settings should go.   This includes things like:\n\n\n\n\nPLUGINS\n: The list of plugins to run,\n\n\nPLUGIN_BLACKLIST\n: The list of plugins to ignore, even if they're in \nPLUGINS\n,\n\n\nPUBLIC_URL\n: The publicly accessible URL will can reach himself at (used for \nkeepalive\n),\n\n\nHTTPSERVER_PORT\n: The port will should handle HTTP requests on.  Defaults to 80, set to \n 1024 if you don't have sudo,\n\n\nREDIS_MAX_CONNECTIONS\n: The maximum number of connections to make to redis, for connection pooling.\n\n\nROOMS\n: The list of rooms to join,\n\n\nDEFAULT_ROOM\n: The room to send messages that come from web requests to,\n\n\nTEMPLATE_DIRS\n: Extra directories to look for templates,\n\n\nADMINS\n: The mention names of all the admins,\n\n\nLOGLEVEL\n: What logging level to use,\n\n\nHIPCHAT_SERVER\n: if you're using the \nHipChat server beta\n, the hostname of the server,\n\n\nALLOW_INSECURE_HIPCHAT_SERVER\n: the option to disable SSL checks (seriously, don't),\n\n\nPROXY_URL\n: Proxy server to use, consider exporting it as \nWILL_PROXY_URL\n environment variable, if it contains sensitive information\n\n\nand all of your non-sensitive plugin settings.\n\n\n\n\nMore expansive documentation on all of those settings is in \nconfig.py\n, right where you need it.\n\n\nHow environment variables and config.py are combined\n\n\nThe environment variables and config.py are combined, and made available to the rest of the app at:\n\n\nfrom will import settings\n\nprint settings.MY_SETTING_NAME\n\n\n\n\nThe rules for combining are fairly straightforward:\n\n\n\n\nAll environment variables that start with \nWILL_\n are imported, and \nWILL_\n is stripped off their name. (i.e. \nWILL_PORT\n becomes \nPORT\n)\n\n\n\n\nAll variables from \nconfig.py\n are imported.  If there is a conflict, \nconfig.py\n wins, and a message is displayed:\n\n\n\n\n\n\n\n\nSome smart defaulting happens inside settings.py for important variables.  For the moment, I'm going to leave that out of the docs, and refer you to \nsettings.py\n as I \nbelieve\n things should Just Work, and most people should never need to care.  If this decision's wrong, please open an issue, and these docs will be improved!\n\n\n\n\n\n\nThat's it for config.  Now, let's get your will \ndeployed\n!", 
            "title": "Configure"
        }, 
        {
            "location": "/config/#configuring-will", 
            "text": "Most of will's configuration is done interactively, using  run_will.py , or specifying via the plugins.  There are, however a few built-in settings and config worth covering.  We'll aim to address all of them here.", 
            "title": "Configuring Will"
        }, 
        {
            "location": "/config/#environment-variables", 
            "text": "All environment variables prefixed with  WILL_  are imported into will's  settings  modules.  In best practices, you should keep all of the following in environment variables:   WILL_USERNAME  WILL_PASSWORD  WILL_REDIS_URL  WILL_V2_TOKEN  WILL_V1_TOKEN  Any other tokens, keys, passwords, or sensitive URLS.   We've made it easy.  No excuses. :)", 
            "title": "Environment variables"
        }, 
        {
            "location": "/config/#configpy", 
            "text": "Config.py is where all of your non-sensitive settings should go.   This includes things like:   PLUGINS : The list of plugins to run,  PLUGIN_BLACKLIST : The list of plugins to ignore, even if they're in  PLUGINS ,  PUBLIC_URL : The publicly accessible URL will can reach himself at (used for  keepalive ),  HTTPSERVER_PORT : The port will should handle HTTP requests on.  Defaults to 80, set to   1024 if you don't have sudo,  REDIS_MAX_CONNECTIONS : The maximum number of connections to make to redis, for connection pooling.  ROOMS : The list of rooms to join,  DEFAULT_ROOM : The room to send messages that come from web requests to,  TEMPLATE_DIRS : Extra directories to look for templates,  ADMINS : The mention names of all the admins,  LOGLEVEL : What logging level to use,  HIPCHAT_SERVER : if you're using the  HipChat server beta , the hostname of the server,  ALLOW_INSECURE_HIPCHAT_SERVER : the option to disable SSL checks (seriously, don't),  PROXY_URL : Proxy server to use, consider exporting it as  WILL_PROXY_URL  environment variable, if it contains sensitive information  and all of your non-sensitive plugin settings.   More expansive documentation on all of those settings is in  config.py , right where you need it.", 
            "title": "config.py"
        }, 
        {
            "location": "/config/#how-environment-variables-and-configpy-are-combined", 
            "text": "The environment variables and config.py are combined, and made available to the rest of the app at:  from will import settings\n\nprint settings.MY_SETTING_NAME  The rules for combining are fairly straightforward:   All environment variables that start with  WILL_  are imported, and  WILL_  is stripped off their name. (i.e.  WILL_PORT  becomes  PORT )   All variables from  config.py  are imported.  If there is a conflict,  config.py  wins, and a message is displayed:     Some smart defaulting happens inside settings.py for important variables.  For the moment, I'm going to leave that out of the docs, and refer you to  settings.py  as I  believe  things should Just Work, and most people should never need to care.  If this decision's wrong, please open an issue, and these docs will be improved!    That's it for config.  Now, let's get your will  deployed !", 
            "title": "How environment variables and config.py are combined"
        }, 
        {
            "location": "/deploy/", 
            "text": "Deploying your Will\n\n\nWill's happy to run on your machine all day, every day.  But he really shines out in production where he can run independently of anything you do with your local machine.  Here are some best practices for deploying will.\n\n\nDeploy on Heroku\n\n\nHeroku is our recommended platform for deployment because it's simple, easy, and free. That's a tough combination to beat.  You're in no way locked in to running will on heroku, though - run him wherever you want!\n\n\nStep 1: Set up your heroku app, and a redis addon.\n\n\nAssuming you have the \nheroku toolbelt\n installed and all set up, it's as easy as this:\n\n\nheroku create our-will-name\nheroku addons:add rediscloud\n\n\n\n\nA note on rediscloud: you can also use redistogo, openredis, or anyone else.  We use rediscloud and like them.\n\n\nStep 2: Add all the needed environment variables:\n\n\nYou'll want to take all the variables that live in your virtualenv's \npostactivate\n file that feed into your will environment, and provide them to your heroku app.\n\n\nAt minimum, that's\n\n\nheroku config:set \\\nWILL_PUBLIC_URL=\nhttp://our-will-name.herokuapp.com\n \\\nWILL_USERNAME='12345_123456@chat.hipchat.com' \\\nWILL_PASSWORD='asj2498q89dsf89a8df' \\\nWILL_V2_TOKEN='asdfjl234jklajfa3azfasj3afa3jlkjiau' \\\n\n\n\n\nIf you have more than 30 chat rooms, you must also set the V1 token to avoid hipchat rate limits:\n\n\nheroku config:set WILL_V1_TOKEN='kjadfj89a34878adf78789a4fae3'\n\n\n\n\nFinally, for will's schedule to be correct, you need to set him to the time zone you want:\n\n\nheroku config:set TZ=\nAmerica/Los_Angeles\n\n\n\n\n\nNote:\n You don't have to worry about setting the \nREDIS_URL\n or \nHTTPSERVER_PORT\n.  Will auto-detects those and takes care of it.\n\n\nStep 3: Deploy!\n\n\nYou're all set to deploy your will. Ready? Go!\n\n\ngit push heroku\n\n\n\n\nYou app is now up on heroku.  Finally, turn it on!\n\n\nheroku scale web=1\n\n\nThat should be it - head over to \nhttp://our-will-name.herokuapp.com\n, and you should see will's smiling face.\n\n\nIf so, pop into chat, and give a:\n\n\n\n\nDeploying future updates\n\n\nJust commit your updates, then\n\n\ngit push heroku\n\n\n\n\nSimple.  For best-practices, see our continuous deployment recommendations below.\n\n\nDeploy Everywhere Else\n\n\nWill is Just Python\n\n\nThat says it all. Will is just python, and you can deploy him \nanywhere\n you have python, an open port, and access to redis.\n\n\nIn your chosen deploy environment and setup, you'll want to do a couple things:\n\n\nReplicate your environment settings\n\n\nAt minimum, that's:\n\n\nexport WILL_PUBLIC_URL=\nhttp://our-will-name.herokuapp.com\n\nexport WILL_USERNAME='12345_123456@chat.hipchat.com'\nexport WILL_PASSWORD='asj2498q89dsf89a8df'\nexport WILL_V2_TOKEN='asdfjl234jklajfa3azfasj3afa3jlkjiau'\nexport WILL_REDIS_URL='redis://some-domain.com/7/'\nexport WILL_HTTPSERVER_PORT='80'\n\n\n\n\nIf you have more than 30 chat rooms, you must also set the V1 token to avoid hipchat rate limits:\n\n\nexport WILL_V1_TOKEN='kjadfj89a34878adf78789a4fae3'\n\n\n\n\nYou'll also need to set any environment variables for your plugins.\n\n\nCall run_will with something that handles restarts and crashes.\n\n\nThe command to kick off will is just:\n\n\npython run_will.py\n\n\n\n\nYou can run that with whatever supervisory process you'd like. Will's very, very stable, but having something that handles crashes is still a pretty good idea.\n\n\nAlternate approach\n\n\nAh, you say, but I have this crazy python-twisted-zope-node monolith that self-repairs mars and can do everything. Why do I need the shell at all?\n\n\nAnswer, crazy monolith mars person: you don't.  Will is Just Python.\n\n\nfrom will.main import WillBot\n\nbot = WillBot()\nbot.bootstrap()\n\n\n\n\nand you're good.\n\n\nStorage Backends\n\n\nWill's default storage backend is Redis, but he supports some others if you can't run Redis.\n\n\nTo change the backend, just set \nSTORAGE_BACKEND\n in \nconfig.py\n and then supply any other needed settings for the new storage backend.  The currently supported backends are:\n\n\n\n\nredis\n - The default Redis backend\n\n\ncouchbase\n - A Couchbase backend\n\n\nfile\n - Keeps the settings as files on a local filesystem\n\n\n\n\nCouchbase\n\n\nCouchbase requries you set \nCOUCHBASE_URL\n in your config.\n\n\nYou are also required to have the python Couchbase client (and thus, libcouchbase) installed.  If you are installing for development you can use \npip install -r requirements.couchbase.txt\n to pull in the Couchbase client.  See \nthe Python Couchbase client repo\n for more info.\n\n\nExamples:\n\n\n\n\nCOUCHBASE_URL='couchbase:///bucket'\n\n\nCOUCHBASE_URL='couchbase://hostname/bucket'\n\n\nCOUCHBASE_URL='couchbase://host1,host2/bucket'\n\n\nCOUCHBASE_URL='couchbase://hostname/bucket?password=123abc\ntimeout=5'\n\n\n\n\nFile\n\n\nFile requires you set \nFILE_DIR\n in your config to point to an empty directory.\n\n\nExamples:\n\n\n\n\nFILE_DIR='/var/run/will/settings/'\n\n\nFILE_DIR='~will/settings/'\n\n\n\n\nBest Practices\n\n\nIn this section, we describe how we deploy and host will, in the hopes that others come forward and share what's working for them, too.  The more good practices, the better.\n\n\nOur Stack\n\n\nWe host on heroku, using rediscloud for redis, mailgun for email, and things have been peachy.  We deploy via CD using CircleCI. Details on that below.\n\n\nUse Continuous Deployment\n\n\nOur stack is set up so that any pushes on will's master branch have tests run on \nCircleCI\n, and if they pass, a new version is deployed to heroku immediately.  This has been delightful. Even though will has very, very minimal tests, we generally catch if things are horribly broken, and it's meant that adding new functionality to will takes minutes, sometimes seconds of developer time.\n\n\nContinuous Deployment has dramatically changed how we build and use will - instead of talking about \"what if will did...\", generally, people just implement it, push it, and play with it for real.  It's been a great place to be.  It might be for you too.\n\n\nThat's it in getting your will up and running!   But maybe you're one of those people who wants to pitch in and make will even better. Awesome. Learn \nhow to improve will\n.", 
            "title": "Deploy"
        }, 
        {
            "location": "/deploy/#deploying-your-will", 
            "text": "Will's happy to run on your machine all day, every day.  But he really shines out in production where he can run independently of anything you do with your local machine.  Here are some best practices for deploying will.", 
            "title": "Deploying your Will"
        }, 
        {
            "location": "/deploy/#deploy-on-heroku", 
            "text": "Heroku is our recommended platform for deployment because it's simple, easy, and free. That's a tough combination to beat.  You're in no way locked in to running will on heroku, though - run him wherever you want!  Step 1: Set up your heroku app, and a redis addon.  Assuming you have the  heroku toolbelt  installed and all set up, it's as easy as this:  heroku create our-will-name\nheroku addons:add rediscloud  A note on rediscloud: you can also use redistogo, openredis, or anyone else.  We use rediscloud and like them.  Step 2: Add all the needed environment variables:  You'll want to take all the variables that live in your virtualenv's  postactivate  file that feed into your will environment, and provide them to your heroku app.  At minimum, that's  heroku config:set \\\nWILL_PUBLIC_URL= http://our-will-name.herokuapp.com  \\\nWILL_USERNAME='12345_123456@chat.hipchat.com' \\\nWILL_PASSWORD='asj2498q89dsf89a8df' \\\nWILL_V2_TOKEN='asdfjl234jklajfa3azfasj3afa3jlkjiau' \\  If you have more than 30 chat rooms, you must also set the V1 token to avoid hipchat rate limits:  heroku config:set WILL_V1_TOKEN='kjadfj89a34878adf78789a4fae3'  Finally, for will's schedule to be correct, you need to set him to the time zone you want:  heroku config:set TZ= America/Los_Angeles   Note:  You don't have to worry about setting the  REDIS_URL  or  HTTPSERVER_PORT .  Will auto-detects those and takes care of it.  Step 3: Deploy!  You're all set to deploy your will. Ready? Go!  git push heroku  You app is now up on heroku.  Finally, turn it on!  heroku scale web=1  That should be it - head over to  http://our-will-name.herokuapp.com , and you should see will's smiling face.  If so, pop into chat, and give a:   Deploying future updates  Just commit your updates, then  git push heroku  Simple.  For best-practices, see our continuous deployment recommendations below.", 
            "title": "Deploy on Heroku"
        }, 
        {
            "location": "/deploy/#deploy-everywhere-else", 
            "text": "Will is Just Python  That says it all. Will is just python, and you can deploy him  anywhere  you have python, an open port, and access to redis.  In your chosen deploy environment and setup, you'll want to do a couple things:  Replicate your environment settings  At minimum, that's:  export WILL_PUBLIC_URL= http://our-will-name.herokuapp.com \nexport WILL_USERNAME='12345_123456@chat.hipchat.com'\nexport WILL_PASSWORD='asj2498q89dsf89a8df'\nexport WILL_V2_TOKEN='asdfjl234jklajfa3azfasj3afa3jlkjiau'\nexport WILL_REDIS_URL='redis://some-domain.com/7/'\nexport WILL_HTTPSERVER_PORT='80'  If you have more than 30 chat rooms, you must also set the V1 token to avoid hipchat rate limits:  export WILL_V1_TOKEN='kjadfj89a34878adf78789a4fae3'  You'll also need to set any environment variables for your plugins.  Call run_will with something that handles restarts and crashes.  The command to kick off will is just:  python run_will.py  You can run that with whatever supervisory process you'd like. Will's very, very stable, but having something that handles crashes is still a pretty good idea.  Alternate approach  Ah, you say, but I have this crazy python-twisted-zope-node monolith that self-repairs mars and can do everything. Why do I need the shell at all?  Answer, crazy monolith mars person: you don't.  Will is Just Python.  from will.main import WillBot\n\nbot = WillBot()\nbot.bootstrap()  and you're good.", 
            "title": "Deploy Everywhere Else"
        }, 
        {
            "location": "/deploy/#storage-backends", 
            "text": "Will's default storage backend is Redis, but he supports some others if you can't run Redis.  To change the backend, just set  STORAGE_BACKEND  in  config.py  and then supply any other needed settings for the new storage backend.  The currently supported backends are:   redis  - The default Redis backend  couchbase  - A Couchbase backend  file  - Keeps the settings as files on a local filesystem   Couchbase  Couchbase requries you set  COUCHBASE_URL  in your config.  You are also required to have the python Couchbase client (and thus, libcouchbase) installed.  If you are installing for development you can use  pip install -r requirements.couchbase.txt  to pull in the Couchbase client.  See  the Python Couchbase client repo  for more info.  Examples:   COUCHBASE_URL='couchbase:///bucket'  COUCHBASE_URL='couchbase://hostname/bucket'  COUCHBASE_URL='couchbase://host1,host2/bucket'  COUCHBASE_URL='couchbase://hostname/bucket?password=123abc timeout=5'   File  File requires you set  FILE_DIR  in your config to point to an empty directory.  Examples:   FILE_DIR='/var/run/will/settings/'  FILE_DIR='~will/settings/'", 
            "title": "Storage Backends"
        }, 
        {
            "location": "/deploy/#best-practices", 
            "text": "In this section, we describe how we deploy and host will, in the hopes that others come forward and share what's working for them, too.  The more good practices, the better.  Our Stack  We host on heroku, using rediscloud for redis, mailgun for email, and things have been peachy.  We deploy via CD using CircleCI. Details on that below.  Use Continuous Deployment  Our stack is set up so that any pushes on will's master branch have tests run on  CircleCI , and if they pass, a new version is deployed to heroku immediately.  This has been delightful. Even though will has very, very minimal tests, we generally catch if things are horribly broken, and it's meant that adding new functionality to will takes minutes, sometimes seconds of developer time.  Continuous Deployment has dramatically changed how we build and use will - instead of talking about \"what if will did...\", generally, people just implement it, push it, and play with it for real.  It's been a great place to be.  It might be for you too.  That's it in getting your will up and running!   But maybe you're one of those people who wants to pitch in and make will even better. Awesome. Learn  how to improve will .", 
            "title": "Best Practices"
        }, 
        {
            "location": "/improve/", 
            "text": "Making Will Better and Better\n\n\nWill is built entirely on the shoulders of giants, and has a great community of developers that move it forward. He wouldn't exist without all of them.\n\n\nWe also welcome new contributions no matter how big or small.  Interested in contributing to will? We'd love to have you. Details below.\n\n\nOur Culture\n\n\nAnyone is welcome to contribute to will, regardless of skill level or experience.  To make will the best he can be, we have one big, overriding cultural principle:\n\n\nBe kind.\n\n\nSimple.  Easy, right?\n\n\nWe've all been newbie coders, we've all had bad days, we've all been frustrated with libraries, we've all spoken a language we learned later in life.  In discussions with other coders, PRs, and CRs, we just give each the benefit of the doubt, listen well, and assume best intentions.  It's worked out fantastically.\n\n\nThis doesn't mean we don't have honest, spirited discussions about the direction to move will forward, or how to implement a feature.  We do.  We just respect one other while we do it.  Not so bad, right? :)\n\n\nImprove will's core\n\n\nFor big core features, you're probably best off opening an issue, and discussing it with one of the core developers \nbefore\n you hack your nights and weekends away.\n\n\nCore changes to will are very much welcome.  In some cases, proposed changes have already been thought through, and there may be gotchas or sticking points we couldn't get past.  In other cases, it might be a direction we've purposely decided not to take will.  In most cases, we simply haven't thought of it, and would love the improvement! \n\n\nIt's always great to get a heads up of what's coming down the pipe, and have an open dialog.  Thanks for reaching out and starting one!\n\n\nIn terms of the mechanics, you'll just want to:\n\n\n\n\nFork this repo.\n\n\nClone down a copy, set up redis and the env, as before.\n\n\nRun \n./start_dev_will.py\n to start up just core will.\n\n\n\n\nContribute new plugins\n\n\nThis one's pretty simple. Write good, clean code that does one thing well, document it properly, and submit a PR!\n\n\nTo submit a plugin that's running in your will,\n\n\n\n\nFork this repo.\n\n\nClone down a copy, set up redis and the env, as before.\n\n\npip install -r requirements.dev.txt\n\n\nCopy your plugin and docs over to the core will repo,\n\n\nRun \n./start_dev_will.py\n to start up just core will, and test it out!\n\n\n\n\nCode standards and PRs\n\n\nThis one's hopefully straightforward:\n\n\n\n\nIncoming code should follow PEP8\n\n\nIf you add new core-level features, please add documentation in the \ndocs\n folder (we use mkdocs).  If you're not sure if they're needed, just ask!\n\n\nPlease add your name and attribution to the AUTHORS file.\n\n\nKnow you have our thanks for helping to make will even better!\n\n\n\n\nTests\n\n\nShamefully, tests are just getting rolling, and a proper, well-architected test harness is in the works. However, there are \nsome\n tests you can run by running:\n\n\ncoverage run -m nose\n\n\n\n\nMore soon!\n\n\nThe Shoulders of Giants\n\n\nWill leverages some fantastic libraries.  He wouldn't exist without them.\n\n\n\n\nBottle\n for http handling,\n\n\nJinja\n for templating,\n\n\nSleekxmpp\n for listening to xmpp,\n\n\nnatural\n and \nparsedatetime\n for natural date parsing,\n\n\napscheduler\n for scheduled task parsing,\n\n\nRequests\n to make http sane.\n\n\n\n\nWill was originally written and is maintained by \nSteven Skoczen\n.  Credit to GreenKahuna (now defunct) and \nBuddyUp\n for supporting those efforts with on-the-job time.\n\n\nWill's also has had help from lots of coders. Alphabetically:\n\n\n\n\nadamcin\n gave you html support in 1-1 chats, using the new v2 API, and made bootstrapping more reliable.\n\n\nadamgilman\n gave you the friendly error messages when the hipchat key was invalid.\n\n\namckinley\n fixed a bug in the hipchat user list from missing params.\n\n\nbfhenderson\n removed dependence on the v1 token, and made help more friendly.\n\n\nborgstrom\n gave you beautifully architected storage backends, including support for couchbase and local storage.\n\n\nbrandonsturgeon\n jumped on hipchat's API-breaking change, and made will immune in a flash.  Fixed the docs, too.\n\n\nbsvetchine\n fixed a bug with README generation.\n\n\ncarsongee\n pooled your redis connections.\n\n\ncamilonova\n fixed the \n@randomly\n decorator, and brought the joy of more pugs to your life.  He's also reported several important bugs.\n\n\nckcollab\n was one of the original contributors, when will was first built at GreenKahuna.\n\n\ncharlax\n gave us batch-get of rooms via the V2 API.\n\n\ncrccheck\n gave you friendly error messages if your \nWILL_ROOMS\n was wrong.\n\n\nd0ugal\n fixed up the docs to meet the new mkdocs standard.\n\n\ndpoirier\n figured out how to properly ignore the initial catch-up messages, and gave you log-level control.\n\n\ndmuntean\n gave you proxy support, and kept it working..\n\n\nIronykins\n brought you urban dictionary support.\n\n\nkenden\n fixed up the redis docs for ubuntu/debian.\n\n\njbeluch\n found a bug with \nget_roster\n not populating in time.\n\n\njessamynsmith\n was kind enough to port \ntalkbackbot\n over, at my request, then kept it updated through version changes.\n\n\njquast\n did the noble and oft unappreciated work of spelling fixes.\n\n\nkeNzi\n added shorten url function using bitly service.\n\n\nlevithomason\n was one of the original contributors, when will was first built at GreenKahuna.\n\n\nhobson\n made setup.py more robust across operating systems, and improved the docs.\n\n\nneronmoon\n made it easier to mention will with non-standard case\n\n\nmichaeljoseph\n suggested improvements to setup and requirements.txt format.\n\n\nmrgrue\n added support for the hipchat server beta.\n\n\nmvanbaak\n brought you support for bitbucket uptime.\n\n\nnetjunkie\n fixed a duplicated help module, added an expire parameter to \nself.save()\n, and added support for will watching hipchat's status.\n\n\npcurry\n added travis support.\n\n\nPrideRage\n gave you access to a room's entire history, and suggested a better talkback regex.\n\n\nquixeybrian\n wrote the awesome new help system and stopped the rate limit nightmare.\n\n\nrbp\n added the \nadmin_only\n argument, and fixed a bug with \nroom\n not being passed along properly to messages.\n\n\nshadow7412\n cleaned up a bunch of regex\n\n\nsivy\n added a config flag for disabling SSL, and the ability to look up a user by nickname.\n\n\ntomokas\n fixed a bug in the \n@randomly\n decorator.\n\n\nwohali\n tracked down the annoying DNS thread issue, and got will on the right path.\n\n\nwoohgit\n added support for the v2 WorldWeatherOnline API, and fixed it when I broke it, and then fixed it again when they changed their endpoint.  He also taught will how to say his version number.  And \nremind ___ to ___ at ___\n.  Awesome. And fixed lots of docs.  And put the time zone with \"what time is it?\".  And then added an entire Pagerduty workflow.  And made message parsing more reliable.  And wrote the ACL support.  And even more doc fixes. And improvements on uptime monitoring edge cases. Yep.\n\n\n\n\nOther Wills\n\n\nIf you're looking for plugin inspiration, here are some wills that are open-sourced:\n\n\n\n\nBuddyUp's will\n\n\nGreenKahuna's will\n\n\nSkoczen's will\n\n\n\n\nNote:\n Have a will you've open-sourced? Please send it in a PR or Issue!  This list is tiny!\n\n\nReleases\n\n\n0.9.3 - September 11, 2015\n\n\nThanks for your patience on this long-delayed release!  Here's what's new:\n\n\n\n\nNew: Will watches bitbucket, and alerts on downtime, thanks to \nmvanbaak\n.\n\n\nNew: \n@will urban dictionary\n, thanks to \nIronykins\n.\n\n\nImprovement: More specific regexes for hi, clear storage, and a few others thanks to \nshadow7412\n.\n\n\nImprovement: Batch-getting of rooms, thanks to \ncharlax\n.\n\n\nImprovement: Better handling of uptime check edge cases, thanks to \nwoohgit\n.\n\n\nImprovement: Proper docs for installing redis on ubuntu/debian, thanks to \nkenden\n.\n\n\nImprovement: Pulled an extraneous doc page, thanks to \nwoohgit\n.\n\n\nImprovement: Fixes to the route doc syntax, thanks to \nbrandonsturgeon\n.\n\n\nImprovement: Docs now fit the new mkdocs format, thanks to \nd0ugal\n.\n\n\n\n\nImprovement: New travis.yml setup for easier travis running, and plugged my CircleCI builds into the github repo. All future PRs should automatically have tests run!\n\n\n\n\n\n\nFixes bug that caused will not to join all rooms if \nROOMS\n was missing. Thanks to \ncamilonova\n for the report!\n\n\n\n\n\n\n0.9.2 - June 5, 2015\n\n\n\n\nFixes bug that caused will not to join all rooms if \nROOMS\n was missing. Thanks to \ncamilonova\n for the report!\n\n\n\n\n0.9.1 - May 30, 2015\n\n\n\n\nFixes bug that affected \n@will\ns - thanks to \nwoohgit\n for the report!\n\n\n\n\n0.9 - May 29, 2015\n\n\n\n\nBREAKING:\n Module change. New \nwill.plugins.fun\n module. Existing will installs will need to add it to your \nconfig.py\n to keep the fun!\n\n\nNew:  Support for Pagerduty workflows, thanks to \nwoohgit\n. This is really tremendous stuff. \nCheck out the docs here\n!\n\n\nNew: \nPluggable storage backends\n, with support for couchbase and local file storage, in addition to redis.  Many thanks to \nborgstrom\n\n\nNew: \nACL\n functionality, thanks to \nwoohgit\n.  Backwards-compatable, even!\n\n\nNew: Made will a little more fun, thanks to \ncamilonova\n.  Hint: it involves the world's most meme-friendly dog.\n\n\nNew: Will can now construct google poems, thanks to \nAirbornePorcine\n. Truly, his creativity knows no bounds.\n\n\nImprovement: Moved stuff like that into a new \"fun\" module.  Dry, anti-fun people can now disable it more easily. ;)\n\n\nImprovement: \"What time is it\" now outputs time zones, thanks to \nwoohgit\n.\n\n\nImprovement: No more rate-limit problems on the v2 token, thanks to \ngrundprinzip\n.\n\n\nImprovement: Messages are now \n.strip()\ned before being compared, to handle \nfrozen-fingered-typos\n.  Thanks, \nwoohgit\n!\n\n\nFix: Typo in the docs gone.  Thanks, \nwoohgit\n.\n\n\nFix: Bugs in proxy support are fixed, thanks to \ndmuntean\n.\n\n\n\n\n0.8.2 - April 24, 2015\n\n\n\n\nFixes an odd remaining bug with \n@randomly\n, thanks to \ncamilonova\n's continued debugging.\n\n\n\n\n0.8.1 - April 23, 2015\n\n\n\n\nMoves \nversion\n plugin into admin, so it just works for most users.\n\n\n\n\n0.8 - April 23, 2015\n\n\n\n\nWhat happens when life gets busy and we go a full month and a half between will releases?  Lots and lots:\n\n\nNew: All-new \n@will who is in this room?\n command, thanks to \npuug\n.\n\n\nNew: Will now can shorten links via bitly \n@will bitly http://example.com\n, thanks to \nkeNzi\n.\n\n\nNew: Will now supports a \nPROXY_URL\n setting, for getting around funky firewalls, thanks to \ndmuntean\n.\n\n\nNew: \n@will version\n command to check version number, thanks to \nwoohgit\n.\n\n\nNew: Awesome new \nremind ___ to ___ at ___\n, thanks to \nwoohgit\n.\n\n\nNew: Will now keeps an eye on hipchat's uptime as well, thanks to \nnetjunki\n.\n\n\nFix: a breaking bug in the \n@randomly\n decorator, thanks to a report by \ncamilonova\n.\n\n\nSupport: Handles a breaking change in the hipchat API, thanks to \nbrandonsturgeon\n.\n\n\nSupport: Updates to v2 of the underquoted API, thanks \njessamynsmith\n.\n\n\nSupport: Updated to the new WorldWeatherOnline endpoint, since they had DDOS problems, thanks to \nwoohgit\n.\n\n\nImprovement: The most important kind of PRs.  Spelling fixes.  Many thanks to \njquast\n.\n\n\nImprovement: \nself.save()\n now accepts an \nexpire\n value, thanks to \nnetjunki\n.\n\n\nImprovement: PEP8 passes for the whole codebase, with flake8 added to automated tests.\n\n\n\n\n0.7.3 - March 3, 2015\n\n\n\n\nFixed a breaking bug to world time, thanks to \nwoohgit\n.\n\n\n\n\n0.7.2 - February 27, 2015\n\n\n\n\nImproved handling when \n.reply()\n is called incorrectly, thanks to a report by \ndothak\n\n\nFixed the \nannoying\n \"github's ok\" on first launch.\n\n\nRestored Python 2.6 compatability thanks to the report and patience of \nJPerkster\n.\n\n\nLots of code cleanup toward pep8.\n\n\n\n\n0.7.1 - February 5, 2015\n\n\n\n\nImproved talkbackbot regex, suggested by \nPrideRage\n.\n\n\n\n\n0.7.0 - February 4, 2015\n\n\n\n\nAdds a port of the awesome \ntalkbackbot\n, thanks to \njessamynsmith\n, who super-kindly ported it at my request!\n\n\nOh, yeah. That port also includes the first proper tests in will, and a pretty solid pattern for testing plugins.  Woo!  More huge thanks to \njessamynsmith\n.\n\n\n\n\n0.6.9 - January 30, 2015\n\n\n\n\nFixed copypasta error caught by the keen eye of \ndpoirier\n.\n\n\n\n\n0.6.8 - January 30, 2015\n\n\n\n\nWill now supports templates directories within plugins.  Just put a \ntemplates\n directory in the plugin's module, and it will be detected.  Thanks to \nsivy\n for the idea and willingness to get it done!\n\n\n\n\n0.6.7 - January 29, 2015\n\n\n\n\nAddition of \n.get_user_by_nick()\n method, to look up users by nick, thanks to \nsivy\n.\n\n\nBugfix to \nALLOW_INSECURE_HIPCHAT_SERVER\n when specified in \nconfig.py\n, thanks to \nsivy\n.\n\n\n\n\n0.6.6 - January 29, 2015\n\n\n\n\nNew \nroom.history\n attribute with a room's history, thanks to \nPrideRage\n\n\nNew setting: \nALLOW_INSECURE_HIPCHAT_SERVER\n, which will disable SSL checks (you're on your own), thanks to \nsivy\n.\n\n\nAdds support for V2 of the WorldWeatherOnline API (used for world times, weather) thanks to \nwoohgit\n.\n\n\nAdds new release and doc deploy scripts, so the github \nreleases\n are kept up to date.  Thanks to \ncrccheck\n for noticing and reporting they were stale!\n\n\n\n\n0.6.5 - January 23, 2015\n\n\n\n\nRemoves mkdocs from the production requirements.txt to fix a Jinja version problem.  Thanks to the report from \nPrideRage\n.\n\n\n\n\n0.6.4 - January 19, 2015\n\n\n\n\nSwitches to bottle to cherrypy over gevent, which should solve lingering gevent DNS threading issues, thanks to \nwohali\n.\n\n\nSupport for @will, @WILL, @wIll, thanks to \nneronmoon\n\n\n\n\n0.6.3 - December 30, 2014\n\n\n\n\nBetter error handling for weirdly formatted messages. \n\n\nBetter generated README, thanks to \nbsvetchine\n.\n\n\n\n\n0.6.2 - September 23, 2014\n\n\n\n\nBugfix on \ngenerate_will_project\n, thanks to the report by \nMattyDub\n.\n\n\n\n\n0.6.1 - September 23, 2014\n\n\n\n\nFreezes apscheduler to \n 3.0, since its API was backwards incompatibile.\n\n\n\n\n0.6.0 - September 17, 2014\n\n\n\n\nMethods in a single class now share a common instance, thanks to \namckinley\n.\n\n\nRedis connections are now pooled (which should help with \"max clients exceeded\" errors), thanks to \ncarsongee\n.\n\n\nPreliminary travis ci support, thanks to \npcurry\n.\n\n\nMore gramatically correct documentation by \nhobson\n.\n\n\n\n\n0.5.7 - September 3, 2014\n\n\n\n\nImprovements to setup.py to be robust a variety of linux/unixes by \nhobson\n.\n\n\n\n\n0.5.6 - August 26, 2014\n\n\n\n\nFix for 1-1 bootstrapping bug, thanks to \nadamcin\n.\n\n\n\n\n0.5.5 - August 25, 2014\n\n\n\n\nFull html support in 1-1 chats, thanks to \nadamcin\n.\n\n\n\n\n0.5.4 - July 22, 2014\n\n\n\n\nUpgrades bottle to 0.12.6 to fix \nsecurity bug\n.\n\n\n\n\n0.5.3 - July 11, 2014\n\n\n\n\n@randomly\n functions now can run on the 59th minute, thanks to \ntomokas\n.\n\n\nBad merge that duplicated \nhelp.py\n fixed by \nnetjunki\n.\n\n\n\"global name 'params' is not defined\" bug fixed by \namckinley\n.\n\n\n\n\n0.5.1 - July 2, 2014\n\n\n\n\nNew \nHIPCHAT_SERVER\n setting to support \nbeta HipChat Server\n, thanks to \nmrgrue\n.\n\n\n\n\n0.5 Omnibus - June 27, 2014\n\n\n\n\nBig, big release, with backwards-incompatble changes.  Please read all the notes on this one!\n\n\nAll-new config and environment setup, including an all-new \nconfig.py\n for plugin configuration, and all non-sensitive settings.\n\n\nMuch, much improved bootstrapping code that validates settings, gives helpful output, and generally helps you get will running.\n\n\nDocumentation!  Real-live documentation! \n\n\nBreaking\n: \nWILL_TOKEN\n has been renamed \nWILL_V1_TOKEN\n.\n\n\nNew \n@require_settings\n decorator for plugins to request validation that needed settings are present.\n\n\nWill now has a concept of modules (groups of plugins), and groups help output according.\n\n\n\n\n0.4.10 - June 6, 2014\n\n\n\n\nBrand-new \nadmin_only\n argument to \nhear()\n and \nrespond_to()\n, thanks to \nrbp\n.  If a user is not in \nWILL_ADMINS\n, they won't be able to run any \nadmin_only=True\n plugins.  Default for \nWILL_ADMINS\n is all users to retain backwards-compatibility.\n\n\nAll commands in the \nstorage.py\n plugin are now admin-only.\n\n\nhelp\n now only responds to direct asks, allowing other plugins to handle \"help me with x\", thanks to \nbfhenderson\n\n\n\n\n0.4.9 - May 28, 2014\n\n\n\n\nPassing a \nroom\n to a \n.say()\n now works properly, thanks to \nrbp\n.\n\n\nNew optional \nWILL_LOGLEVEL\n setting, thanks to \ndpoirier\n.\n\n\n\n\n0.4.8 - May 21, 2014\n\n\n\n\nWill now ignores all previously sent messages properly, by passing in \nbot\n as the resource instead of an ugly time hack, thanks to \ndpoirier\n.\n\n\n\n\n0.4.7 - May 15, 2014\n\n\n\n\nWill now prints a helpful message if one of your \nWILL_ROOMS\n is wrong, and continues starting, instead of crashing in a fiery ball, thanks to \ncrccheck\n.\n\n\n\n\n0.4.6 - May 5, 2014\n\n\n\n\n@route\n decorators now honor all bottle arguments, most helpfully \nmethod\n! \n\n\n\n\n0.4.5 - May 2, 2014\n\n\n\n\nAwesome new help system by \nquixeybrian\n.  \n\n\n\"@will help\" now only displays functions with docstrings, and formats them nicely.\n\n\nOld help (regexes and all) is available at \"@will programmer help\"\n\n\n\n\n0.4.4 - April 22, 2014\n\n\n\n\nRemoves the dependence on the v1 token (though it still helps with rate-limiting), thanks to \nbfhenderson\n.\n\n\nMuch friendlier error message on an invalid API key, thanks to \nadamgilman\n.\n\n\n\n\n0.4.3 - ~ April 1, 2014\n\n\n\n\nSupport for hundreds of users and rooms without hitting the API limit.\n\n\nget_all_users\n use of the bulk API \nadded\n by \nquixeybrian\n.  Thanks also to \njbeluch\n and \njdrukman\n for nudges in the right direction.\n\n\nThe start of some useful comments - the meat of will was hacked out by one person over a handful of days and it looks that way. Slowly but surely making this codebase more friendly to other contributions!\n\n\nAdded a CONTRIBUTING.md file thanks to \nmichaeljoseph\n.\n\n\nProper releases in the docs, and an updated \nAUTHORS\n file.  If you see something awry, send a PR!\n\n\n\n\n0.4 - ~ March 2014\n\n\n\n\n\n\nYe olden past before we started keeping this list.  All contributions by GreenKahuna.  Will did everything that's not in the release list above.  That's called lazy retconning release lists!\n\n\n\n\n\n\nMake sure nothing from the readme is missed.", 
            "title": "Improve"
        }, 
        {
            "location": "/improve/#making-will-better-and-better", 
            "text": "Will is built entirely on the shoulders of giants, and has a great community of developers that move it forward. He wouldn't exist without all of them.  We also welcome new contributions no matter how big or small.  Interested in contributing to will? We'd love to have you. Details below.", 
            "title": "Making Will Better and Better"
        }, 
        {
            "location": "/improve/#our-culture", 
            "text": "Anyone is welcome to contribute to will, regardless of skill level or experience.  To make will the best he can be, we have one big, overriding cultural principle:  Be kind.  Simple.  Easy, right?  We've all been newbie coders, we've all had bad days, we've all been frustrated with libraries, we've all spoken a language we learned later in life.  In discussions with other coders, PRs, and CRs, we just give each the benefit of the doubt, listen well, and assume best intentions.  It's worked out fantastically.  This doesn't mean we don't have honest, spirited discussions about the direction to move will forward, or how to implement a feature.  We do.  We just respect one other while we do it.  Not so bad, right? :)", 
            "title": "Our Culture"
        }, 
        {
            "location": "/improve/#improve-wills-core", 
            "text": "For big core features, you're probably best off opening an issue, and discussing it with one of the core developers  before  you hack your nights and weekends away.  Core changes to will are very much welcome.  In some cases, proposed changes have already been thought through, and there may be gotchas or sticking points we couldn't get past.  In other cases, it might be a direction we've purposely decided not to take will.  In most cases, we simply haven't thought of it, and would love the improvement!   It's always great to get a heads up of what's coming down the pipe, and have an open dialog.  Thanks for reaching out and starting one!  In terms of the mechanics, you'll just want to:   Fork this repo.  Clone down a copy, set up redis and the env, as before.  Run  ./start_dev_will.py  to start up just core will.", 
            "title": "Improve will's core"
        }, 
        {
            "location": "/improve/#contribute-new-plugins", 
            "text": "This one's pretty simple. Write good, clean code that does one thing well, document it properly, and submit a PR!  To submit a plugin that's running in your will,   Fork this repo.  Clone down a copy, set up redis and the env, as before.  pip install -r requirements.dev.txt  Copy your plugin and docs over to the core will repo,  Run  ./start_dev_will.py  to start up just core will, and test it out!", 
            "title": "Contribute new plugins"
        }, 
        {
            "location": "/improve/#code-standards-and-prs", 
            "text": "This one's hopefully straightforward:   Incoming code should follow PEP8  If you add new core-level features, please add documentation in the  docs  folder (we use mkdocs).  If you're not sure if they're needed, just ask!  Please add your name and attribution to the AUTHORS file.  Know you have our thanks for helping to make will even better!", 
            "title": "Code standards and PRs"
        }, 
        {
            "location": "/improve/#tests", 
            "text": "Shamefully, tests are just getting rolling, and a proper, well-architected test harness is in the works. However, there are  some  tests you can run by running:  coverage run -m nose  More soon!", 
            "title": "Tests"
        }, 
        {
            "location": "/improve/#the-shoulders-of-giants", 
            "text": "Will leverages some fantastic libraries.  He wouldn't exist without them.   Bottle  for http handling,  Jinja  for templating,  Sleekxmpp  for listening to xmpp,  natural  and  parsedatetime  for natural date parsing,  apscheduler  for scheduled task parsing,  Requests  to make http sane.   Will was originally written and is maintained by  Steven Skoczen .  Credit to GreenKahuna (now defunct) and  BuddyUp  for supporting those efforts with on-the-job time.  Will's also has had help from lots of coders. Alphabetically:   adamcin  gave you html support in 1-1 chats, using the new v2 API, and made bootstrapping more reliable.  adamgilman  gave you the friendly error messages when the hipchat key was invalid.  amckinley  fixed a bug in the hipchat user list from missing params.  bfhenderson  removed dependence on the v1 token, and made help more friendly.  borgstrom  gave you beautifully architected storage backends, including support for couchbase and local storage.  brandonsturgeon  jumped on hipchat's API-breaking change, and made will immune in a flash.  Fixed the docs, too.  bsvetchine  fixed a bug with README generation.  carsongee  pooled your redis connections.  camilonova  fixed the  @randomly  decorator, and brought the joy of more pugs to your life.  He's also reported several important bugs.  ckcollab  was one of the original contributors, when will was first built at GreenKahuna.  charlax  gave us batch-get of rooms via the V2 API.  crccheck  gave you friendly error messages if your  WILL_ROOMS  was wrong.  d0ugal  fixed up the docs to meet the new mkdocs standard.  dpoirier  figured out how to properly ignore the initial catch-up messages, and gave you log-level control.  dmuntean  gave you proxy support, and kept it working..  Ironykins  brought you urban dictionary support.  kenden  fixed up the redis docs for ubuntu/debian.  jbeluch  found a bug with  get_roster  not populating in time.  jessamynsmith  was kind enough to port  talkbackbot  over, at my request, then kept it updated through version changes.  jquast  did the noble and oft unappreciated work of spelling fixes.  keNzi  added shorten url function using bitly service.  levithomason  was one of the original contributors, when will was first built at GreenKahuna.  hobson  made setup.py more robust across operating systems, and improved the docs.  neronmoon  made it easier to mention will with non-standard case  michaeljoseph  suggested improvements to setup and requirements.txt format.  mrgrue  added support for the hipchat server beta.  mvanbaak  brought you support for bitbucket uptime.  netjunkie  fixed a duplicated help module, added an expire parameter to  self.save() , and added support for will watching hipchat's status.  pcurry  added travis support.  PrideRage  gave you access to a room's entire history, and suggested a better talkback regex.  quixeybrian  wrote the awesome new help system and stopped the rate limit nightmare.  rbp  added the  admin_only  argument, and fixed a bug with  room  not being passed along properly to messages.  shadow7412  cleaned up a bunch of regex  sivy  added a config flag for disabling SSL, and the ability to look up a user by nickname.  tomokas  fixed a bug in the  @randomly  decorator.  wohali  tracked down the annoying DNS thread issue, and got will on the right path.  woohgit  added support for the v2 WorldWeatherOnline API, and fixed it when I broke it, and then fixed it again when they changed their endpoint.  He also taught will how to say his version number.  And  remind ___ to ___ at ___ .  Awesome. And fixed lots of docs.  And put the time zone with \"what time is it?\".  And then added an entire Pagerduty workflow.  And made message parsing more reliable.  And wrote the ACL support.  And even more doc fixes. And improvements on uptime monitoring edge cases. Yep.", 
            "title": "The Shoulders of Giants"
        }, 
        {
            "location": "/improve/#other-wills", 
            "text": "If you're looking for plugin inspiration, here are some wills that are open-sourced:   BuddyUp's will  GreenKahuna's will  Skoczen's will   Note:  Have a will you've open-sourced? Please send it in a PR or Issue!  This list is tiny!", 
            "title": "Other Wills"
        }, 
        {
            "location": "/improve/#releases", 
            "text": "0.9.3 - September 11, 2015  Thanks for your patience on this long-delayed release!  Here's what's new:   New: Will watches bitbucket, and alerts on downtime, thanks to  mvanbaak .  New:  @will urban dictionary , thanks to  Ironykins .  Improvement: More specific regexes for hi, clear storage, and a few others thanks to  shadow7412 .  Improvement: Batch-getting of rooms, thanks to  charlax .  Improvement: Better handling of uptime check edge cases, thanks to  woohgit .  Improvement: Proper docs for installing redis on ubuntu/debian, thanks to  kenden .  Improvement: Pulled an extraneous doc page, thanks to  woohgit .  Improvement: Fixes to the route doc syntax, thanks to  brandonsturgeon .  Improvement: Docs now fit the new mkdocs format, thanks to  d0ugal .   Improvement: New travis.yml setup for easier travis running, and plugged my CircleCI builds into the github repo. All future PRs should automatically have tests run!    Fixes bug that caused will not to join all rooms if  ROOMS  was missing. Thanks to  camilonova  for the report!    0.9.2 - June 5, 2015   Fixes bug that caused will not to join all rooms if  ROOMS  was missing. Thanks to  camilonova  for the report!   0.9.1 - May 30, 2015   Fixes bug that affected  @will s - thanks to  woohgit  for the report!   0.9 - May 29, 2015   BREAKING:  Module change. New  will.plugins.fun  module. Existing will installs will need to add it to your  config.py  to keep the fun!  New:  Support for Pagerduty workflows, thanks to  woohgit . This is really tremendous stuff.  Check out the docs here !  New:  Pluggable storage backends , with support for couchbase and local file storage, in addition to redis.  Many thanks to  borgstrom  New:  ACL  functionality, thanks to  woohgit .  Backwards-compatable, even!  New: Made will a little more fun, thanks to  camilonova .  Hint: it involves the world's most meme-friendly dog.  New: Will can now construct google poems, thanks to  AirbornePorcine . Truly, his creativity knows no bounds.  Improvement: Moved stuff like that into a new \"fun\" module.  Dry, anti-fun people can now disable it more easily. ;)  Improvement: \"What time is it\" now outputs time zones, thanks to  woohgit .  Improvement: No more rate-limit problems on the v2 token, thanks to  grundprinzip .  Improvement: Messages are now  .strip() ed before being compared, to handle  frozen-fingered-typos .  Thanks,  woohgit !  Fix: Typo in the docs gone.  Thanks,  woohgit .  Fix: Bugs in proxy support are fixed, thanks to  dmuntean .   0.8.2 - April 24, 2015   Fixes an odd remaining bug with  @randomly , thanks to  camilonova 's continued debugging.   0.8.1 - April 23, 2015   Moves  version  plugin into admin, so it just works for most users.   0.8 - April 23, 2015   What happens when life gets busy and we go a full month and a half between will releases?  Lots and lots:  New: All-new  @will who is in this room?  command, thanks to  puug .  New: Will now can shorten links via bitly  @will bitly http://example.com , thanks to  keNzi .  New: Will now supports a  PROXY_URL  setting, for getting around funky firewalls, thanks to  dmuntean .  New:  @will version  command to check version number, thanks to  woohgit .  New: Awesome new  remind ___ to ___ at ___ , thanks to  woohgit .  New: Will now keeps an eye on hipchat's uptime as well, thanks to  netjunki .  Fix: a breaking bug in the  @randomly  decorator, thanks to a report by  camilonova .  Support: Handles a breaking change in the hipchat API, thanks to  brandonsturgeon .  Support: Updates to v2 of the underquoted API, thanks  jessamynsmith .  Support: Updated to the new WorldWeatherOnline endpoint, since they had DDOS problems, thanks to  woohgit .  Improvement: The most important kind of PRs.  Spelling fixes.  Many thanks to  jquast .  Improvement:  self.save()  now accepts an  expire  value, thanks to  netjunki .  Improvement: PEP8 passes for the whole codebase, with flake8 added to automated tests.   0.7.3 - March 3, 2015   Fixed a breaking bug to world time, thanks to  woohgit .   0.7.2 - February 27, 2015   Improved handling when  .reply()  is called incorrectly, thanks to a report by  dothak  Fixed the  annoying  \"github's ok\" on first launch.  Restored Python 2.6 compatability thanks to the report and patience of  JPerkster .  Lots of code cleanup toward pep8.   0.7.1 - February 5, 2015   Improved talkbackbot regex, suggested by  PrideRage .   0.7.0 - February 4, 2015   Adds a port of the awesome  talkbackbot , thanks to  jessamynsmith , who super-kindly ported it at my request!  Oh, yeah. That port also includes the first proper tests in will, and a pretty solid pattern for testing plugins.  Woo!  More huge thanks to  jessamynsmith .   0.6.9 - January 30, 2015   Fixed copypasta error caught by the keen eye of  dpoirier .   0.6.8 - January 30, 2015   Will now supports templates directories within plugins.  Just put a  templates  directory in the plugin's module, and it will be detected.  Thanks to  sivy  for the idea and willingness to get it done!   0.6.7 - January 29, 2015   Addition of  .get_user_by_nick()  method, to look up users by nick, thanks to  sivy .  Bugfix to  ALLOW_INSECURE_HIPCHAT_SERVER  when specified in  config.py , thanks to  sivy .   0.6.6 - January 29, 2015   New  room.history  attribute with a room's history, thanks to  PrideRage  New setting:  ALLOW_INSECURE_HIPCHAT_SERVER , which will disable SSL checks (you're on your own), thanks to  sivy .  Adds support for V2 of the WorldWeatherOnline API (used for world times, weather) thanks to  woohgit .  Adds new release and doc deploy scripts, so the github  releases  are kept up to date.  Thanks to  crccheck  for noticing and reporting they were stale!   0.6.5 - January 23, 2015   Removes mkdocs from the production requirements.txt to fix a Jinja version problem.  Thanks to the report from  PrideRage .   0.6.4 - January 19, 2015   Switches to bottle to cherrypy over gevent, which should solve lingering gevent DNS threading issues, thanks to  wohali .  Support for @will, @WILL, @wIll, thanks to  neronmoon   0.6.3 - December 30, 2014   Better error handling for weirdly formatted messages.   Better generated README, thanks to  bsvetchine .   0.6.2 - September 23, 2014   Bugfix on  generate_will_project , thanks to the report by  MattyDub .   0.6.1 - September 23, 2014   Freezes apscheduler to   3.0, since its API was backwards incompatibile.   0.6.0 - September 17, 2014   Methods in a single class now share a common instance, thanks to  amckinley .  Redis connections are now pooled (which should help with \"max clients exceeded\" errors), thanks to  carsongee .  Preliminary travis ci support, thanks to  pcurry .  More gramatically correct documentation by  hobson .   0.5.7 - September 3, 2014   Improvements to setup.py to be robust a variety of linux/unixes by  hobson .   0.5.6 - August 26, 2014   Fix for 1-1 bootstrapping bug, thanks to  adamcin .   0.5.5 - August 25, 2014   Full html support in 1-1 chats, thanks to  adamcin .   0.5.4 - July 22, 2014   Upgrades bottle to 0.12.6 to fix  security bug .   0.5.3 - July 11, 2014   @randomly  functions now can run on the 59th minute, thanks to  tomokas .  Bad merge that duplicated  help.py  fixed by  netjunki .  \"global name 'params' is not defined\" bug fixed by  amckinley .   0.5.1 - July 2, 2014   New  HIPCHAT_SERVER  setting to support  beta HipChat Server , thanks to  mrgrue .   0.5 Omnibus - June 27, 2014   Big, big release, with backwards-incompatble changes.  Please read all the notes on this one!  All-new config and environment setup, including an all-new  config.py  for plugin configuration, and all non-sensitive settings.  Much, much improved bootstrapping code that validates settings, gives helpful output, and generally helps you get will running.  Documentation!  Real-live documentation!   Breaking :  WILL_TOKEN  has been renamed  WILL_V1_TOKEN .  New  @require_settings  decorator for plugins to request validation that needed settings are present.  Will now has a concept of modules (groups of plugins), and groups help output according.   0.4.10 - June 6, 2014   Brand-new  admin_only  argument to  hear()  and  respond_to() , thanks to  rbp .  If a user is not in  WILL_ADMINS , they won't be able to run any  admin_only=True  plugins.  Default for  WILL_ADMINS  is all users to retain backwards-compatibility.  All commands in the  storage.py  plugin are now admin-only.  help  now only responds to direct asks, allowing other plugins to handle \"help me with x\", thanks to  bfhenderson   0.4.9 - May 28, 2014   Passing a  room  to a  .say()  now works properly, thanks to  rbp .  New optional  WILL_LOGLEVEL  setting, thanks to  dpoirier .   0.4.8 - May 21, 2014   Will now ignores all previously sent messages properly, by passing in  bot  as the resource instead of an ugly time hack, thanks to  dpoirier .   0.4.7 - May 15, 2014   Will now prints a helpful message if one of your  WILL_ROOMS  is wrong, and continues starting, instead of crashing in a fiery ball, thanks to  crccheck .   0.4.6 - May 5, 2014   @route  decorators now honor all bottle arguments, most helpfully  method !    0.4.5 - May 2, 2014   Awesome new help system by  quixeybrian .    \"@will help\" now only displays functions with docstrings, and formats them nicely.  Old help (regexes and all) is available at \"@will programmer help\"   0.4.4 - April 22, 2014   Removes the dependence on the v1 token (though it still helps with rate-limiting), thanks to  bfhenderson .  Much friendlier error message on an invalid API key, thanks to  adamgilman .   0.4.3 - ~ April 1, 2014   Support for hundreds of users and rooms without hitting the API limit.  get_all_users  use of the bulk API  added  by  quixeybrian .  Thanks also to  jbeluch  and  jdrukman  for nudges in the right direction.  The start of some useful comments - the meat of will was hacked out by one person over a handful of days and it looks that way. Slowly but surely making this codebase more friendly to other contributions!  Added a CONTRIBUTING.md file thanks to  michaeljoseph .  Proper releases in the docs, and an updated  AUTHORS  file.  If you see something awry, send a PR!   0.4 - ~ March 2014    Ye olden past before we started keeping this list.  All contributions by GreenKahuna.  Will did everything that's not in the release list above.  That's called lazy retconning release lists!    Make sure nothing from the readme is missed.", 
            "title": "Releases"
        }
    ]
}